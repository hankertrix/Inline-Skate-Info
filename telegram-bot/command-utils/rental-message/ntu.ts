// Module to create the rental message for NTU

import {
  type RentalMessageCallbackHandler,
  type RentalMessageHandler,
  defaultCallbackHandler,
} from ".";
import type { InlineKeyboardButton, InlineKeyboardMarkup, ParseMode } from "telegraf/types";
import { Markup, Scenes, Types } from "telegraf";
import * as utils from "../../utils";
import {
  type FormatOptions,
  type IsSameNameFunc,
  type PollConfig,
  NUMBERING_STYLES,
  createPollPortion,
  getName,
  reformPollMessage,
  getPollMessage,
  defaultIsSameNameFunc,
  getPollOptions,
} from "../poll-message";
import { deleteMessages, removeCommand } from "../../bot-utils";
import { getUpcomingTrainingDates } from "../training-message/utils";
import { trainingDates } from "../training-message/ntu";
import {
  answerIfGlobalLimitIsHit,
  answerRentalMessageCbQuery,
} from "./utils";
import { DEFAULT_RENTAL_MSG_CONFIG } from "./defaults";


// The rental options
const RENTAL_OPTIONS = [
  "Sizes 38 - 41",
  "Sizes 42 - 45"
];

// The available sizes for rental
const SIZES = [
  "38", "39", "40", "41",
  "42", "43", "44", "45"
];

// The maximum number of rentals for each size group
const MAX_NUMBER_OF_RENTALS = [
  3,
  3
];

// The format options for the NTU rental message function
const RENTAL_MSG_FORMAT_OPTIONS: FormatOptions = {

  // The {people} in the formatStr property will be substituted
  // with the string generated by substituting the zero, one, and
  // moreThanOne properties.

  // The {number} in the zero, one and default properties
  // will be substituted with the actual number of people who
  // responded to the poll option.

  // The {maxEntries} in the zero, one and default properties
  // will be substituted with the maximum number of people
  // allowed on that particular poll option

  // The options for the individual options of the poll
  pollOptionHeader: {

    // The format string for the header of a single poll option
    // The {pollOption} in the formatStr will be substituted with
    // the poll option.
    // The formatStr should start with the poll option,
    // otherwise the callback query won't work unless the regular expression
    // in the getPollOptionSegment function is changed as the current
    // regular expression matches from the start of the line.
    formatStr: "{pollOption} {people}",

    // Whether to bold the header or not.
    // The poll option header should be bolded.
    bold: true,

    // The string to display when there is more than one person.
    // This is also the string that will be used if no string is given
    // for zero and one.
    default: "({number}/{maxEntries} pairs left)",

    // The string to display when there is no one
    zero: null,

    // The string to display when there is one person
    one: null
  },

  // The options for the message footer.
  // The message footer is empty for the rental message
  messageFooter: {

    // The format string for the header of the poll message.
    formatStr: "",

    // Whether to bold the message footer or not.
    // The message footer should not be bolded.
    bold: false,

    // The string to display when there is more than one person.
    // This is also the string that will be used if no string is given
    // for zero and one.
    default: "",

    // The string to display when there is no one
    zero: "",

    // The string to display when there is one person
    one: ""
  }
};


// The rental message configuration
const RENTAL_MSG_CONFIG: Required<PollConfig> = {
  ...DEFAULT_RENTAL_MSG_CONFIG,
  pollOptions: RENTAL_OPTIONS,
  maxEntriesList: MAX_NUMBER_OF_RENTALS,
  numberingStyle: NUMBERING_STYLES.DASH,
  formatOptions: RENTAL_MSG_FORMAT_OPTIONS,
  maxNumberOfVotes: 1,
  isSameNameFunc: isSameName,
  inlineKeyboardGenerator: generateInlineKeyboard(SIZES),
} as const;

// The rental message
const RENTAL_MSG = `
{time}
Add your name if you want skate rentals. $5 for the whole session. Please either scan the PayNow QR code above or PayNow the $5 to ${process.env.NTU_TREASURER_PHONE_NUMBER}. Press the ${RENTAL_MSG_CONFIG.tagString} button to indicate that you have paid. First come first served basis!!!
`.trim();


// The regular expression to remove the size and the tag string
// from the name
const removeTagAndSizeRegex = new RegExp(
  String.raw`\d+[^\S\r\n]*${
    utils.regexEscape(RENTAL_MSG_CONFIG.tagString)
  }?$`
);

// The regular expression to get the size range
const getSizeRangeRegex = /(\d+)[^\S\r\n]-[^\S\r\n](\d+)/;


// The function to check if two names are the same
function isSameName(
  ...[encounteredName, givenName]: Parameters<IsSameNameFunc>
): ReturnType<IsSameNameFunc> {

  // If the given name is null, return false
  if (givenName == null) return false;

  // Otherwise, removes the tag and the size from
  // both the encountered name and the given name, trims them both
  // and returns if both are the same
  return encounteredName.replace(
    removeTagAndSizeRegex, ""
  ).trim() === givenName.replace(removeTagAndSizeRegex, "").trim();
}


// Function to create the time portion of the rental message
function createRentalMessagePortion(
  rentalMsg: string,
  trainingDates: string[]
) {

  // Get the upcoming training date
  const upcomingTrainingDate = getUpcomingTrainingDates(
    trainingDates
  ) as Date;

  // Gets the day of the week
  const dayOfTheWeek = Intl.DateTimeFormat("en-SG", {
    weekday: "long"
  }).format(upcomingTrainingDate);

  // Gets the date string
  const dateStr = Intl.DateTimeFormat("en-SG", {
    month: "2-digit",
    day: "2-digit"
  }).format(upcomingTrainingDate);

  // The time portion of the rental message
  const timePortion = `${dayOfTheWeek} rentals! (${dateStr})`;

  // Add the time portion to the rental message and return the rental message
  return utils.strFormat(rentalMsg, { time: timePortion });
}


// The function to generate an inline keyboard for the NTU rental message
function generateInlineKeyboard(
  sizes: string[] = SIZES
): () => Types.Markup<InlineKeyboardMarkup> {

  // Initialise the inline keyboard
  const inlineKeyboard: InlineKeyboardButton[][] = [];

  // Gets the length of the sizes array
  const sizesLength = sizes.length;

  // Iterates over the sizes in the sizes array
  for (let index = 0; index < sizesLength; index += 2) {

    // Checks if index + 1 is greater than
    // or equal to the length of the array
    if (index + 1 >= sizesLength) {

      // Then just add the size at the current index
      inlineKeyboard.push([
        Markup.button.callback(
          sizes[index],
          sizes[index]
        )
      ]);
    }

    // Otherwise, add the two sizes at index and at index + 1
    else {
      inlineKeyboard.push([
        Markup.button.callback(
          sizes[index],
          sizes[index]
        ),
        Markup.button.callback(
          sizes[index + 1],
          sizes[index + 1]
        )
      ]);
    }
  }

  // Adds the tag string as the last option to the inline keyboard
  inlineKeyboard.push([
    Markup.button.callback(
      RENTAL_MSG_CONFIG.tagString,
      RENTAL_MSG_CONFIG.tagString
    )
  ]);

  // Returns the inline keyboard
  return () => Markup.inlineKeyboard(inlineKeyboard);
}


// Function to create the rental message
// This function is very similar to the generatePollMessage function
// in the poll message module.
function generateRentalMessage(
  message: string,
  pollConfig: Required<PollConfig> = RENTAL_MSG_CONFIG
) {

  // Remove the command and the bot's username from the message
  message = removeCommand(message);

  // Generate the portion of the message that is a poll
  const pollPortion = createPollPortion(pollConfig);

  // Create the inline keyboard
  const inlineKeyboard = pollConfig.inlineKeyboardGenerator(SIZES);

  // The callback function
  async function callback(ctx: Scenes.WizardContext, input: string) {

    // Bold the first line of the input
    input = utils.boldFirstLine(input);

    // Sends a poll with the user's input
    return await ctx.reply(
      `${input}${pollConfig.pollType}${pollConfig.pollSpacing}${pollPortion}`,
      {
        parse_mode: "HTML",
        ...inlineKeyboard
      }
    );
  }

  // Returns the message and the callback function
  return { userMessage: message, callback: callback };
}


// The handler for the rental message command
export async function handler(
  ...[
    ctx,
    message
  ]: Parameters<RentalMessageHandler>
): ReturnType<RentalMessageHandler> {

  // Generates the rental message
  const { userMessage, callback } = generateRentalMessage(message);

  // If the user's message isn't empty
  if (userMessage) {

    // Call the callback function with the user's message
    await callback(ctx, userMessage);

    // Deletes the user's message
    return await deleteMessages(ctx, ctx.message.message_id);
  }

  // Otherwise, create the rental message portion
  const rentalMsgPortion = createRentalMessagePortion(
    RENTAL_MSG, trainingDates
  );

  // Sends the QR code
  await ctx.replyWithPhoto(
    { source: "./static/ntu/rentals-paynow-qr-code.jpg" }
  );

  // Calls the callback function with the default rental message portion
  await callback(ctx, rentalMsgPortion);

  // Deletes the user's message
  return await deleteMessages(ctx, ctx.message.message_id);
}


// The handler for the callback query
export async function callbackHandler(
  ...[
    ctx,
    callbackQuery,
    messageText
  ]: Parameters<RentalMessageCallbackHandler>
): ReturnType<RentalMessageCallbackHandler> {

  // Initialise the poll configuration object
  const pollConfig = RENTAL_MSG_CONFIG;

  // The variable to determine if the button pressed is the tag button
  const tag = callbackQuery.data === pollConfig.tagString;

  // Gets the message object
  const message = callbackQuery.message;

  // Gets the poll options.
  // Skip the last option in the inline keyboard
  // as it is the tag string and not an actual poll option
  const pollOptions = getPollOptions(
    message.reply_markup.inline_keyboard.slice(0, -1)
  );

  // If the poll options aren't the same as the list of sizes
  if (!utils.arraysAreEqual(pollOptions, SIZES)) {

    // Then it means the poll isn't the rental message that has been
    // set up for NTU, it is instead a custom rental message.
    // Hence, call the defaultCallbackHandler to handle it instead.
    return await defaultCallbackHandler(ctx, callbackQuery, messageText);
  }

  // Otherwise, gets the poll message
  const pollMessage = getPollMessage(messageText, RENTAL_OPTIONS);

  // Gets the name of the user
  const name = getName(callbackQuery.from);

  // Gets the size chosen
  const chosenSize = parseInt(callbackQuery.data);

  // Create the additional options to edit the message
  const additionalOptions = {
    parse_mode: "HTML" as ParseMode,
    reply_markup: {
      inline_keyboard: message.reply_markup.inline_keyboard
    }
  };

  // Initialise the selected rental option variable
  // to an empty string if tagging, otherwise, null
  let selectedRentalOption = tag ? "" : null;

  // If the button pressed isn't the tag string
  if (!tag) {

    // Iterates over the rental options
    for (const option of RENTAL_OPTIONS) {

      // Gets the match for the size range
      const match = option.match(getSizeRangeRegex);

      // If the match is empty
      if (!match) {

        // Tells the user to tell the developer an error has occurred
        return await ctx.answerCbQuery(
          `Please tell the developer about this error.\nError: The regex match for the size range is null.`
        );
      };

      // Otherwise, get the smallest and largest size in the range
      const [ , smallest, largest] = match.map(number => parseInt(number));

      // If the chosen size is within the range
      if (chosenSize >= smallest && chosenSize <= largest) {

        // Set the selected rental option to the current rental option
        selectedRentalOption = option;
      }
    }
  }

  // If the selected rental option is null somehow,
  // and the button pressed isn't the tag button.
  if (!selectedRentalOption && !tag) {

    // Tells the user that the poll option doesn't exist
    return await ctx.answerCbQuery(
      `The option "${
        callbackQuery.data
      }" doesn't exist on the rental message you are responding to.`
    );
  }

  // The entry to put in the rental message
  const entry = tag ? name : `${name} ${chosenSize}`;

  // Set the is same name function in the poll configuration object
  pollConfig.isSameNameFunc = tag ? isSameName : defaultIsSameNameFunc;

  // Gets the reformed poll message
  const { reformedPollMessage, removed, tagged } = reformPollMessage(
    messageText,
    pollMessage,
    selectedRentalOption as string,
    RENTAL_OPTIONS,
    entry,
    pollConfig,
    tag ? pollConfig.tagString : null,
  );

  // Gets if the poll-wide limit for the rental message has been reached
  const limitHit = await answerIfGlobalLimitIsHit(
    ctx,
    reformedPollMessage,
    name,
    pollConfig.maxNumberOfVotes
  );

  // If the limit has been reached, exit the function
  if (limitHit) return;

  // Answers the rental message callback query
  const shouldEditMessage = await answerRentalMessageCbQuery(
    ctx, tag, removed, tagged, selectedRentalOption
  );

  // If the message should be edited,
  // edits the message with the reformed poll message
  // and exits the function
  if (shouldEditMessage) {
    return await ctx.editMessageText(reformedPollMessage, additionalOptions);
  }
}


// The help text for the NTU command
export const help = `To use the /rental_msg command, simply type the command and the rental message will be sent to the group.

If you would like to change the rental message to a custom one, provide the rental message after you have typed the command, like this:
${utils.monospace(`/rental_msg ${utils.stripHtml("<custom rental message (optional)>")}`)}`;
