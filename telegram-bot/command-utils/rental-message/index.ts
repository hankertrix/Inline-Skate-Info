// The utility functions for the rental message
// and create rental message command

import type { Scenes } from "telegraf";
import type { Message } from "telegraf/types";
import {
  type CreatePollMessagePrompts,
  type AdditionalOptionsFunction,
  type FormatOptions,
  type CreatePollMessageConfig,
  POLL_TYPES,
} from "../poll";
import { DEV } from "$lib/constants";
import { getModuleString } from "../../utils";
import {
  generateInlineKeyboard,
  promptUserForInput,
  removeBotUsernameAndCommand
} from "../../bot-utils";


// The type of the rental message function
export type RentalMessageFunction = (
  ctx: Scenes.WizardContext & { message: Message.TextMessage },
  message: string
) => Promise<unknown>;

// The interface for the rental message module
interface RentalMessageModule {
  handler: RentalMessageFunction,
  help: string
};

// The type of the rental message modules
type RentalMessageModules = {
  [name: string]: RentalMessageModule
};

// The dictionary containing all of the mappings between the name
// and the rental message module
const rentalMsgModules: RentalMessageModules = {
} as const;

// The rental option message
const rentalOptionMessage = `Please enter another rental option.

Use the /done command to get the bot to send the rental message.`;

// The default prompts for the create rental message function
const DEFAULT_CREATE_RENTAL_MSG_PROMPTS: CreatePollMessagePrompts = [

  // The prompt for the first step
  "Please enter the rental message.",

  // The prompts for the second step
  {
    success: "Please enter the first rental option.",
    failure: {
      prompt: "Please choose a numbering style from the list.",
      placeholder: "Choose a numbering style..."
    },
  },

  // The prompts for the third step
  { success: rentalOptionMessage, failure: "Please enter a rental option." }
] as const;


// The default format options for the create rental message function
const DEFAULT_RENTAL_MSG_FORMAT_OPTIONS: FormatOptions = {

  // The {people} in the formatStr property will be substituted
  // with the string generated by substituting the zero, one, and
  // moreThanOne properties.

  // The {number} in the zero, one and default properties
  // will be substituted with the actual number of people who
  // responded to the poll option.

  // The {maxEntries} in the zero, one and defulat properties
  // will be substituted with the maximum number of people
  // allowed on that particular poll option

  // The options for the individual options of the poll
  pollOptionHeader: {

    // The format string for the header of a single poll option
    // The {pollOption} in the formatStr will be substituted with
    // the poll option.
    // The formatStr should start with the poll option,
    // otherwise the callback query won't work unless the regular expression
    // in the getPollOptionSegment function is changed as the current
    // regular expression matches from the start of the line.
    formatStr: "{pollOption} {people}",

    // Whether to bold the header or not.
    // The poll option header should be bolded.
    bold: true,

    // The string to display when there is more than one person.
    // This is also the string that will be used if no string is given
    // for zero and one.
    default: "({number}/{maxEntries})",

    // The string to display when there is no one
    zero: null,

    // The string to display when there is one person
    one: null
  },

  // The options for the message footer.
  // The message footer is empty for the rental message
  messageFooter: {

    // The format string for the header of the poll message.
    formatStr: "",

    // Whether to bold the message footer or not.
    // The message footer should not be bolded.
    bold: false,

    // The string to display when there is more than one person.
    // This is also the string that will be used if no string is given
    // for zero and one.
    default: "",

    // The string to display when there is no one
    zero: "",

    // The string to display when there is one person
    one: ""
  }
};


// The regular expression the get the maximum number of entries
// from the user
const promptForMaxEntriesRegex = /\d+/;


// The default rental message options
export const DEFAULT_CREATE_RENTAL_MSG_CONFIG: CreatePollMessageConfig = {
  prompts: DEFAULT_CREATE_RENTAL_MSG_PROMPTS,
  maxEntriesList: [],
  formatOptions: DEFAULT_RENTAL_MSG_FORMAT_OPTIONS,
  preserveLines: true,
  showRemaining: true,
  pollType: POLL_TYPES.RENTAL,
  inlineKeyboardGenerator: generateInlineKeyboard,
  additionalOptionsFuncList: [
    promptForMaxEntries
  ],
  additionalOptionsIndex: 0
};


// The function to prompt the user for the maximum number of entries
async function promptForMaxEntries(
  ...[ctx, message, state]: Parameters<AdditionalOptionsFunction>
): ReturnType<AdditionalOptionsFunction> {

  // Gets the message from the user
  const msg = removeBotUsernameAndCommand(message);

  // Tries to pull out the numbers in the message
  const maxEntriesMatch = msg.match(promptForMaxEntriesRegex);

  // If there are no matches
  if (!maxEntriesMatch) {

    // Asks the user for the maximum number of entries for the rental option
    // and exit the function
    await promptUserForInput(
      ctx, "Please enter the number of available rentals for this option."
    );

    // Return false to indicate the function failed
    // to get the required information
    return false;
  }

  // Otherwise, get the number of entries from the match object
  const maxEntries = parseInt(maxEntriesMatch[0]);

  // If the maximum number of entries has not been initialised in the state
  if (!Array.isArray(state.maxEntriesList)) {

    // Initialise the maximum number of entries with the given one
    state.maxEntriesList = [maxEntries];
  }

  // Otherwise, add the maximum number of entries to the list
  else state.maxEntriesList.push(maxEntries);

  // Returns true to indicate that the function successfully obtained
  // the required information
  return true;
}


// Function to handler the rental message command
export async function handler(
  ...[ctx, message]: Parameters<RentalMessageFunction>
) {

  // Gets the module string
  const moduleStr = getModuleString(ctx.chat!.id);

  // If the module string isn't found
  if (!moduleStr) {

    // Tells the user that the rental message hasn't been set up
    const botMessage = await ctx.reply(
      `No rental message was found for this chat, so please enter the desired rental message. If you would like to set up a rental message for this chat, please contact ${DEV}.`
    );

    // Enters the create poll message scene with
    // all the default rental message options
    return ctx.scene.enter("createPollMessage", {
      pollOptions: [],
      messagesToDelete: [botMessage.message_id],
      ...DEFAULT_CREATE_RENTAL_MSG_CONFIG
    });
  }

  // Otherwise, gets the rental message function from the module mapping
  const rentalMsgFunction = rentalMsgModules[moduleStr].handler;

  // Calls the rental message function
  await rentalMsgFunction(ctx, message);
}
