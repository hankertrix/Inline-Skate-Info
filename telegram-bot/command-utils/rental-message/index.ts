// The utility functions for the rental message
// and create rental message command

import { type Scenes } from "telegraf";
import type { Message, ParseMode } from "telegraf/types";
import type { CbQuery } from "../../types";
import {
  type CreatePollMessagePrompts,
  type AdditionalOptionsFunction,
  type FormatOptions,
  type CreatePollMessageConfig,
  POLL_TYPES,
  getName,
  getPollOptions,
  getPollMessage,
  reformPollMessage
} from "../poll";
import { DEV } from "$lib/constants";
import { getModuleString } from "../../utils";
import {
  promptUserForInput,
  removeBotUsernameAndCommand
} from "../../bot-utils";
import * as ntu from "./ntu";
import {
  answerRentalMessageCbQuery,
  generateRentalMsgInlineKeyboardFunc
} from "./utils";


// The type of the rental message handler
export type RentalMessageHandler = (
  ctx: Scenes.WizardContext & { message: Message.TextMessage },
  message: string
) => Promise<unknown>;

// The rental message callback context type
type RentalMessageCallbackContext = Scenes.WizardContext & {
  callbackQuery: CbQuery
};

// The type of the rental message callback handler
export type RentalMessageCallbackHandler = (
  ctx: RentalMessageCallbackContext,
  callbackQuery: CbQuery,
  messageText: string,
  tagString?: string
) => Promise<unknown>;

// The interface for the rental message module
interface RentalMessageModule {
  handler: RentalMessageHandler,
  help: string,
  callback_handler?: RentalMessageCallbackHandler
};

// The type of the rental message modules
type RentalMessageModules = {
  [name: string]: RentalMessageModule
};

// The default tag string
export const DEFAULT_TAG_STRING = "âœ…";

// The default option on whether all entries in the rental message
// should be tagged or not
export const DEFAULT_RENTAL_MSG_TAG_ALL = true;

// The dictionary containing all of the mappings between the name
// and the rental message module
const RENTAL_MSG_MODULES: RentalMessageModules = {
  "ntu": ntu
} as const;

// The rental option message
const RENTAL_OPTION_MESSAGE = `Please enter another rental option.

Use the /done command to get the bot to send the rental message.`;

// The default prompts for the create rental message function
const DEFAULT_CREATE_RENTAL_MSG_PROMPTS: CreatePollMessagePrompts = [

  // The prompt for the first step
  "Please enter the rental message.",

  // The prompts for the second step
  {
    success: "Please enter the first rental option.",
    failure: {
      prompt: "Please choose a numbering style from the list.",
      placeholder: "Choose a numbering style..."
    },
  },

  // The prompts for the third step
  {
    success: RENTAL_OPTION_MESSAGE,
    failure: "Please enter a rental option.\n\nUse the /done command to get the bot to send the rental message."
  }
] as const;


// The default format options for the create rental message function
const DEFAULT_RENTAL_MSG_FORMAT_OPTIONS: FormatOptions = {

  // The {people} in the formatStr property will be substituted
  // with the string generated by substituting the zero, one, and
  // moreThanOne properties.

  // The {number} in the zero, one and default properties
  // will be substituted with the actual number of people who
  // responded to the poll option.

  // The {maxEntries} in the zero, one and defulat properties
  // will be substituted with the maximum number of people
  // allowed on that particular poll option

  // The options for the individual options of the poll
  pollOptionHeader: {

    // The format string for the header of a single poll option
    // The {pollOption} in the formatStr will be substituted with
    // the poll option.
    // The formatStr should start with the poll option,
    // otherwise the callback query won't work unless the regular expression
    // in the getPollOptionSegment function is changed as the current
    // regular expression matches from the start of the line.
    formatStr: "{pollOption} {people}",

    // Whether to bold the header or not.
    // The poll option header should be bolded.
    bold: true,

    // The string to display when there is more than one person.
    // This is also the string that will be used if no string is given
    // for zero and one.
    default: "({number}/{maxEntries})",

    // The string to display when there is no one
    zero: null,

    // The string to display when there is one person
    one: null
  },

  // The options for the message footer.
  // The message footer is empty for the rental message
  messageFooter: {

    // The format string for the header of the poll message.
    formatStr: "",

    // Whether to bold the message footer or not.
    // The message footer should not be bolded.
    bold: false,

    // The string to display when there is more than one person.
    // This is also the string that will be used if no string is given
    // for zero and one.
    default: "",

    // The string to display when there is no one
    zero: "",

    // The string to display when there is one person
    one: ""
  }
};


// The default rental message options
export const DEFAULT_CREATE_RENTAL_MSG_CONFIG: CreatePollMessageConfig = {
  prompts: DEFAULT_CREATE_RENTAL_MSG_PROMPTS,
  maxEntriesList: [],
  formatOptions: DEFAULT_RENTAL_MSG_FORMAT_OPTIONS,
  preserveLines: true,
  showRemaining: true,
  pollType: POLL_TYPES.RENTAL,
  inlineKeyboardGenerator: generateRentalMsgInlineKeyboardFunc(
    DEFAULT_TAG_STRING
  ),
  additionalOptionsFuncList: [
    promptForMaxEntries
  ],
  additionalOptionsIndex: 0
};


// The regular expression the get the maximum number of entries
// from the user
const promptForMaxEntriesRegex = /\d+/;


// The function to prompt the user for the maximum number of entries
async function promptForMaxEntries(
  ...[ctx, message, state]: Parameters<AdditionalOptionsFunction>
): ReturnType<AdditionalOptionsFunction> {

  // Gets the message from the user
  const msg = removeBotUsernameAndCommand(message);

  // Tries to pull out the numbers in the message
  const maxEntriesMatch = msg.match(promptForMaxEntriesRegex);

  // If there are no matches
  if (!maxEntriesMatch) {

    // Asks the user for the maximum number of entries for the rental option
    // and exit the function
    await promptUserForInput(
      ctx, "Please enter the number of available rentals for this option."
    );

    // Return false to indicate the function failed
    // to get the required information
    return false;
  }

  // Otherwise, get the number of entries from the match object
  const maxEntries = parseInt(maxEntriesMatch[0]);

  // If the maximum number of entries has not been initialised in the state
  if (!Array.isArray(state.maxEntriesList)) {

    // Initialise the maximum number of entries with the given one
    state.maxEntriesList = [maxEntries];
  }

  // Otherwise, add the maximum number of entries to the list
  else state.maxEntriesList.push(maxEntries);

  // Returns true to indicate that the function successfully obtained
  // the required information
  return true;
}


// Function to handle the rental message command
export async function handler(
  ...[ctx, message]: Parameters<RentalMessageHandler>
) {

  // Gets the module string
  const moduleStr = getModuleString(ctx.chat!.id);

  // If the module string isn't found
  if (!moduleStr) {

    // Tells the user that the rental message hasn't been set up
    const botMessage = await ctx.reply(
      `No rental message was found for this chat, so please enter the desired rental message. If you would like to set up a rental message for this chat, please contact ${DEV}.`
    );

    // Enters the create poll message scene with
    // all the default rental message options
    return ctx.scene.enter("createPollMessage", {
      pollOptions: [],
      messagesToDelete: [botMessage.message_id],
      ...DEFAULT_CREATE_RENTAL_MSG_CONFIG
    });
  }

  // Otherwise, gets the rental message handler from the module mapping
  const rentalMsgHandler = RENTAL_MSG_MODULES[moduleStr].handler;

  // Calls the rental message function
  await rentalMsgHandler(ctx, message);
}


// The default function to use to handle the callback query
export async function default_callback_handler(
  ...[
    ctx,
    callbackQuery,
    messageText,
    tagString = DEFAULT_TAG_STRING
  ]: Parameters<RentalMessageCallbackHandler>
): ReturnType<RentalMessageCallbackHandler> {

  // Gets the rental option
  const rentalOption = callbackQuery.data;

  // Gets the name of the person
  const name = getName(callbackQuery.from);

  // Gets the message object
  const message = callbackQuery.message;

  // Create the additional options to edit the message
  const additionalOptions = {
    parse_mode: "HTML" as ParseMode,
    reply_markup: {
      inline_keyboard: message.reply_markup.inline_keyboard
    }
  };

  // The variable to indicate that the rental option given
  // is the tag string
  const isTag = rentalOption === tagString;

  // If the rental option doesn't exist,
  // and the selected option isn't the tag string
  if (!isTag && messageText.indexOf(rentalOption) === -1) {

    // Tells the user that the poll option doesn't exist
    return await ctx.answerCbQuery(
      `The option "${
        rentalOption
      }" doesn't exist on the rental message you are responding to.`
    );
  }

  // Otherwise, gets the list of rental options
  // The inline keyboard will have the last option removed
  // as that is the option to tag the entry
  const rentalOptions = getPollOptions(
    message.reply_markup.inline_keyboard.slice(0, -1)
  );

  // Gets the rental message
  const rentalMessage = getPollMessage(messageText, rentalOptions);

  // Gets the reformed poll message
  // and the variable to indicated whether the person has been added
  // or removed from the rental option
  const { reformedPollMessage, removed, tagged } = reformPollMessage(
    messageText,
    rentalMessage,
    rentalOption,
    rentalOptions,
    name,
    DEFAULT_RENTAL_MSG_FORMAT_OPTIONS,
    DEFAULT_CREATE_RENTAL_MSG_CONFIG.preserveLines,
    DEFAULT_CREATE_RENTAL_MSG_CONFIG.showRemaining,
    isTag ? tagString : null,
    DEFAULT_RENTAL_MSG_TAG_ALL
  );

  // Answers the rental message callback query
  const shouldEditMessage = await answerRentalMessageCbQuery(
    ctx, isTag, removed, tagged, rentalOption
  );

  // If the message should be edited,
  // edits the message with the reformed poll message
  // and exits the function
  if (shouldEditMessage) {
    return await ctx.editMessageText(reformedPollMessage, additionalOptions);
  }
}


// Function to handle the callback query
export async function callback_handler(
  context: Scenes.WizardContext,
  next: () => Promise<void>,
  tagString: string = DEFAULT_TAG_STRING
) {

  // Casts the context to the correct type
  const ctx = context as Scenes.WizardContext & {
    callbackQuery: CbQuery
  };

  // Gets the callback query and cast it to the CbQuery type
  const callbackQuery = ctx.callbackQuery;

  // Gets the message from the callback query
  const message = callbackQuery.message;

  // Gets the message text
  const messageText = message.text;

  // If the poll type isn't found in the message,
  // calls the next() function and
  // immediately exit the function so that
  // another handler can take care of the message
  if (!messageText.includes(POLL_TYPES.RENTAL)) return await next();

  // Gets the module string from the chat ID
  const moduleStr = getModuleString(message.chat.id);

  // If the module string is found
  if (moduleStr) {

    // Gets the rental message callback handler for the module
    const rentalMsgCbHandler = RENTAL_MSG_MODULES[moduleStr].callback_handler;

    // If the rental message callback exists
    if (rentalMsgCbHandler) {

      // Calls the rental message callback and exit the function
      return await rentalMsgCbHandler(ctx, callbackQuery, messageText);
    }
  }

  // Otherwise, calls the default callback handler
  // to handle the callback query
  return await default_callback_handler(
    ctx, callbackQuery, messageText, tagString
  );
}


// Function to generate the help text for the rental message help command
export function generateHelpText(chatId: number) {

  // Gets the module string
  const moduleStr = getModuleString(chatId);

  // If the module string isn't found
  // (the chat ID wasn't found in the database),
  // then tells the user that the rental message hasn't been set up
  if (!moduleStr) {
    return `The rental message has not been set up for this chat. Please contact ${DEV} if you would like to set up a rental message.`;
  }

  // Gets the help message from the data
  const helpText = RENTAL_MSG_MODULES[moduleStr].help;

  // Returns the help text
  return helpText;
}
