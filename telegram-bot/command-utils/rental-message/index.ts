// The utility functions for the rental message
// and create rental message command

import { Markup, type Scenes } from "telegraf";
import type { Message, ParseMode } from "telegraf/types";
import type { CbQuery } from "../../types";
import {
  type CreatePollMessagePrompts,
  type AdditionalOptionsFunction,
  type FormatOptions,
  type CreatePollMessageConfig,
  POLL_TYPES,
  toggleTagOnEntirePollMessage,
  getName,
  getPollOptions,
  getPollMessage,
  reformPollMessage
} from "../poll";
import { DEV } from "$lib/constants";
import { getModuleString } from "../../utils";
import {
  promptUserForInput,
  removeBotUsernameAndCommand
} from "../../bot-utils";


// The type of the rental message handler
export type RentalMessageHandler = (
  ctx: Scenes.WizardContext & { message: Message.TextMessage },
  message: string
) => Promise<unknown>;

// The type of the rental message callback handler
export type RentalMessageCallbackHandler = (
  ctx: Scenes.WizardContext & { callbackQuery: CbQuery },
  callbackQuery: CbQuery,
  messageText: string,
  tagString?: string
) => Promise<unknown>;

// The interface for the rental message module
interface RentalMessageModule {
  handler: RentalMessageHandler,
  help: string,
  callback_handler?: RentalMessageCallbackHandler
};

// The type of the rental message modules
type RentalMessageModules = {
  [name: string]: RentalMessageModule
};

// The dictionary containing all of the mappings between the name
// and the rental message module
const rentalMsgModules: RentalMessageModules = {
} as const;

// The default tag string
export const DEFAULT_TAG_STRING = "âœ…";

// The rental option message
const rentalOptionMessage = `Please enter another rental option.

Use the /done command to get the bot to send the rental message.`;

// The default prompts for the create rental message function
const DEFAULT_CREATE_RENTAL_MSG_PROMPTS: CreatePollMessagePrompts = [

  // The prompt for the first step
  "Please enter the rental message.",

  // The prompts for the second step
  {
    success: "Please enter the first rental option.",
    failure: {
      prompt: "Please choose a numbering style from the list.",
      placeholder: "Choose a numbering style..."
    },
  },

  // The prompts for the third step
  { success: rentalOptionMessage, failure: "Please enter a rental option." }
] as const;


// The default format options for the create rental message function
const DEFAULT_RENTAL_MSG_FORMAT_OPTIONS: FormatOptions = {

  // The {people} in the formatStr property will be substituted
  // with the string generated by substituting the zero, one, and
  // moreThanOne properties.

  // The {number} in the zero, one and default properties
  // will be substituted with the actual number of people who
  // responded to the poll option.

  // The {maxEntries} in the zero, one and defulat properties
  // will be substituted with the maximum number of people
  // allowed on that particular poll option

  // The options for the individual options of the poll
  pollOptionHeader: {

    // The format string for the header of a single poll option
    // The {pollOption} in the formatStr will be substituted with
    // the poll option.
    // The formatStr should start with the poll option,
    // otherwise the callback query won't work unless the regular expression
    // in the getPollOptionSegment function is changed as the current
    // regular expression matches from the start of the line.
    formatStr: "{pollOption} {people}",

    // Whether to bold the header or not.
    // The poll option header should be bolded.
    bold: true,

    // The string to display when there is more than one person.
    // This is also the string that will be used if no string is given
    // for zero and one.
    default: "({number}/{maxEntries})",

    // The string to display when there is no one
    zero: null,

    // The string to display when there is one person
    one: null
  },

  // The options for the message footer.
  // The message footer is empty for the rental message
  messageFooter: {

    // The format string for the header of the poll message.
    formatStr: "",

    // Whether to bold the message footer or not.
    // The message footer should not be bolded.
    bold: false,

    // The string to display when there is more than one person.
    // This is also the string that will be used if no string is given
    // for zero and one.
    default: "",

    // The string to display when there is no one
    zero: "",

    // The string to display when there is one person
    one: ""
  }
};


// The regular expression the get the maximum number of entries
// from the user
const promptForMaxEntriesRegex = /\d+/;


// The default rental message options
export const DEFAULT_CREATE_RENTAL_MSG_CONFIG: CreatePollMessageConfig = {
  prompts: DEFAULT_CREATE_RENTAL_MSG_PROMPTS,
  maxEntriesList: [],
  formatOptions: DEFAULT_RENTAL_MSG_FORMAT_OPTIONS,
  preserveLines: true,
  showRemaining: true,
  pollType: POLL_TYPES.RENTAL,
  inlineKeyboardGenerator: generateRentalMsgInlineKeyboard,
  additionalOptionsFuncList: [
    promptForMaxEntries
  ],
  additionalOptionsIndex: 0
};


// The function to generate an inline keyboard
function generateRentalMsgInlineKeyboard(
  rentalOptions: string[]
) {

  // The list of inline keyboard buttons
  const inline_keyboard = [];

  // Iterates over the rental options and add them to the inline keyboard
  for (const rentalOption of rentalOptions) {

    // Add the rental option as an inline keyboard button
    inline_keyboard.push(
      [Markup.button.callback(rentalOption, rentalOption)]
    );
  }

  // Adds the default tag string to the inline keyboard
  inline_keyboard.push(
    [Markup.button.callback(DEFAULT_TAG_STRING, DEFAULT_TAG_STRING)]
  );

  // Returns the keyboard
  return Markup.inlineKeyboard(inline_keyboard);
}


// The function to prompt the user for the maximum number of entries
async function promptForMaxEntries(
  ...[ctx, message, state]: Parameters<AdditionalOptionsFunction>
): ReturnType<AdditionalOptionsFunction> {

  // Gets the message from the user
  const msg = removeBotUsernameAndCommand(message);

  // Tries to pull out the numbers in the message
  const maxEntriesMatch = msg.match(promptForMaxEntriesRegex);

  // If there are no matches
  if (!maxEntriesMatch) {

    // Asks the user for the maximum number of entries for the rental option
    // and exit the function
    await promptUserForInput(
      ctx, "Please enter the number of available rentals for this option."
    );

    // Return false to indicate the function failed
    // to get the required information
    return false;
  }

  // Otherwise, get the number of entries from the match object
  const maxEntries = parseInt(maxEntriesMatch[0]);

  // If the maximum number of entries has not been initialised in the state
  if (!Array.isArray(state.maxEntriesList)) {

    // Initialise the maximum number of entries with the given one
    state.maxEntriesList = [maxEntries];
  }

  // Otherwise, add the maximum number of entries to the list
  else state.maxEntriesList.push(maxEntries);

  // Returns true to indicate that the function successfully obtained
  // the required information
  return true;
}


// Function to handle the rental message command
export async function handler(
  ...[ctx, message]: Parameters<RentalMessageHandler>
) {

  // Gets the module string
  const moduleStr = getModuleString(ctx.chat!.id);

  // If the module string isn't found
  if (!moduleStr) {

    // Tells the user that the rental message hasn't been set up
    const botMessage = await ctx.reply(
      `No rental message was found for this chat, so please enter the desired rental message. If you would like to set up a rental message for this chat, please contact ${DEV}.`
    );

    // Enters the create poll message scene with
    // all the default rental message options
    return ctx.scene.enter("createPollMessage", {
      pollOptions: [],
      messagesToDelete: [botMessage.message_id],
      ...DEFAULT_CREATE_RENTAL_MSG_CONFIG
    });
  }

  // Otherwise, gets the rental message handler from the module mapping
  const rentalMsgHandler = rentalMsgModules[moduleStr].handler;

  // Calls the rental message function
  await rentalMsgHandler(ctx, message);
}


// The default function to use to handle the callback query
export async function default_callback_handler(
  ...[
    ctx,
    callbackQuery,
    messageText,
    tagString = DEFAULT_TAG_STRING
  ]: Parameters<RentalMessageCallbackHandler>
): ReturnType<RentalMessageCallbackHandler> {

  // Gets the rental option
  const rentalOption = callbackQuery.data;

  // If the rental option doesn't exist, then tells the user
  if (messageText.indexOf(rentalOption) === -1) {
    return await ctx.answerCbQuery(
      `The option "${
        rentalOption
      }" doesn't exist on the rental message you are responding to.`
    );
  }

  // Otherwise, gets the name of the person
  const name = getName(callbackQuery.from);

  // Gets the message object
  const message = callbackQuery.message;

  // Create the additional options to edit the message
  const additionalOptions = {
    parse_mode: "HTML" as ParseMode,
    reply_markup: {
      inline_keyboard: message.reply_markup.inline_keyboard
    }
  };

  // If the rental option is the tag string
  if (rentalOption === tagString) {

    // Tags the user on the poll message
    const { msg, tagged } = toggleTagOnEntirePollMessage(
      messageText, name, tagString
    );

    // If the tagged variable is null
    if (tagged == null) {

      // Tells the user that they need to add their name to the poll first
      return await ctx.answerCbQuery(
        `You need to add your name to the poll before you can indicate that you have paid.`
      );
    }

    // Otherwise, tells the user that that have indicated that they
    // have or have not paid.
    const callbackReply = tagged
      ? "Successfully indicated that you have paid! Thank you!"
      : "Removed the indication that you have paid.";

    // Sends the callback reply to the user
    await ctx.answerCbQuery(callbackReply);

    // Edit the rental message
    return await ctx.editMessageText(msg, additionalOptions);
  }

  // Otherwise, gets the list of rental options
  const rentalOptions = getPollOptions(message.reply_markup.inline_keyboard);

  // Gets the rental message
  const rentalMessage = getPollMessage(messageText, rentalOptions);

  // Gets the reformed poll message
  // and the variable to indicated whether the person has been added
  // or removed from the rental option
  const { reformedPollMessage, removed } = reformPollMessage(
    messageText,
    rentalMessage,
    rentalOption,
    rentalOptions,
    name,
    DEFAULT_RENTAL_MSG_FORMAT_OPTIONS,
    DEFAULT_CREATE_RENTAL_MSG_CONFIG.preserveLines,
    DEFAULT_CREATE_RENTAL_MSG_CONFIG.showRemaining
  );

  // Answers the callback query
  await ctx.answerCbQuery(
    `Your name has been ${
      removed ? "removed from" : "added to"
    } '${rentalOption}'!`
  );

  // Edits the message with the reformed poll message
  return await ctx.editMessageText(reformedPollMessage, additionalOptions);
}


// Function to handle the callback query
export async function callback_handler(
  context: Scenes.WizardContext,
  next: () => Promise<void>,
  tagString: string = DEFAULT_TAG_STRING
) {

  // Casts the context to the correct type
  const ctx = context as Scenes.WizardContext & {
    callbackQuery: CbQuery
  };

  // Gets the callback query and cast it to the CbQuery type
  const callbackQuery = ctx.callbackQuery;

  // Gets the message from the callback query
  const message = callbackQuery.message;

  // Gets the message text
  const messageText = message.text;

  // If the poll type isn't found in the message,
  // calls the next() function and
  // immediately exit the function so that
  // another handler can take care of the message
  if (!messageText.includes(POLL_TYPES.RENTAL)) return await next();

  // Gets the module string from the chat ID
  const moduleStr = getModuleString(message.chat.id);

  // If the module string is found
  if (moduleStr) {

    // Gets the rental message callback handler for the module
    const rentalMsgCbHandler = rentalMsgModules[moduleStr].callback_handler;

    // If the rental message callback exists
    if (rentalMsgCbHandler) {

      // Calls the rental message callback and exit the function
      return await rentalMsgCbHandler(ctx, callbackQuery, messageText);
    }
  }

  // Otherwise, calls the default callback handler
  // to handle the callback query
  return await default_callback_handler(
    ctx, callbackQuery, messageText, tagString
  );
}
