// The utility functions for the poll command

import type { Scenes } from "telegraf";
import type { User, InlineKeyboardButton } from "telegraf/types";
import type { CbQuery, ObjectValues } from "../types";
import * as utils from "../utils";
import { removeBotUsername } from "../bot-utils"
import { SPACING } from "../../src/lib/constants";


// The enum representing the various poll types
export const POLL_TYPES = {
  DEFAULT: utils.generateZeroWidthCode("default"),
  RENTAL: utils.generateZeroWidthCode("rental"),
} as const;

// The type of poll
export type PollType = ObjectValues<typeof POLL_TYPES>;

// The enum representing the numbering styles for the poll
export const NUMBERING_STYLES = {
  NONE: "",
  DASH: "-",
  ARROWHEAD: ">",
  EQUAL: "=",
  PLUS: "+",
  TILDE: "~",
  SMALL_DOT: "Â·",
  BIG_DOT: "â€¢",
  ROUND_BRACKET: "1)",
  NUMBERED_DOT: "1.",
  ROUND_BRACKETS: "(1)",
  SQUARE_BRACKETS: "[1]",
  CURLY_BRACKETS: "{1}",
  ANGLE_BRACKETS: "<1>",
} as const;

// The regex to get the numbering style
// and the name from the poll option segment
const numberingStyleAndNameRegex =
  /^\s*?([->=+~â€¢Â·([{<]?\d*[).\]}>]?)\s*(.*?)$/gm;

// The type for the numbering styles
export type NumberingStyle = ObjectValues<typeof NUMBERING_STYLES>;

// The default poll options
export const DEFAULT_POLL_OPTIONS = ["Coming"];

// The type of the format option variable
export type FormatOption = {
  formatStr: string,
  default: string,
  zero?: string | null,
  one?: string | null
}

// The type of the format options variable
export type FormatOptions = {
  pollOptionHeader: FormatOption,
  messageFooter: FormatOption
}

// The default format options
export const DEFAULT_FORMAT_OPTIONS: FormatOptions = {

  // The {people} in the formatStr property will be substituted
  // with the string generated by substituting the zero, one, and
  // moreThanOne properties.

  // The {number} in the zero, one and moreThanOne properties
  // will be substituted with the actual number of people who
  // responded to the poll option.

  // The options for the individual options of the poll
  pollOptionHeader: {

    // The format string for the header of a single poll option
    // The {pollOption} in the formatStr will be substituted with
    // the poll option.
    formatStr: "{pollOption} {people}",

    // The string to display when there is more than one person.
    // This is also the string that will be used if no string is given
    // for zero and one.
    default: "({number}ðŸ‘¥)",

    // The string to display when there is no one
    zero: "",

    // The string to display when there is one person
    one: null
  },

  // The options for the message footer
  messageFooter: {

    // The format string for the header of the poll message.
    formatStr: "ðŸ‘¥ {people} responded",

    // The string to display when there is more than one person.
    // This is also the string that will be used if no string is given
    // for zero and one.
    default: "{number} people",

    // The string to display when there is no one
    zero: "Nobody",

    // The string to display when there is one person
    one: "1 person"
  }
}

// The regex for the poll message command
export const pollMessageRegex = /^\/?\bpoll_?(?:msg|message)?\b/i;

// Function to generate the inline keyboard markup
export function generateInlineKeyboard(
  pollOptions: string[] = DEFAULT_POLL_OPTIONS
) {

  // The list of inline keyboard buttons
  const inlineKeyboard = [];

  // Iterates over the poll options and add their buttons to the list
  for (const pollOption of pollOptions) {

    // Adds the poll option button to the list
    inlineKeyboard.push([{
      text: pollOption,
      callback_data: pollOption
    }]);
  }

  // Returns the inline keyboard object
  return inlineKeyboard;
}


// Function to generate the callback function for the poll message command
export function generatePollMessage(
  message: string,
  pollOptions: string[],
  pollType: PollType = POLL_TYPES.DEFAULT
) {

  // Remove the command from the message
  message = message.replace(pollMessageRegex, "").trim();

  // Remove the bot's username from the message
  message = removeBotUsername(message);

  // Generate the portion of the message that is a poll
  const pollPortion = `${pollOptions.map(
    option => `${utils.bold(option)}`
  ).join(SPACING)}${SPACING}ðŸ‘¥ Nobody responded`;

  // Gets the inline keyboard
  const inlineKeyboard = generateInlineKeyboard(pollOptions);

  // The callback function
  async function callback(ctx: Scenes.WizardContext, input: string) {

    // Bold the first line of the input
    input = utils.boldFirstLine(input);

    // Sends a poll with the user's input
    return await ctx.reply(
      `${input}\n${pollType}\n${pollPortion}`,
      {
        parse_mode: "HTML",
        reply_markup: {
          inline_keyboard: inlineKeyboard
        }
      });
  }

  // Returns the message and the callback function
  return { message: message, callback: callback };
}




// All functions relating to the callback query from the poll

// Function to get the data from the poll option segment
export function getPollOptionData(message: string, pollOption: string) {

  // Gets the index of the poll option in the message
  // and set it to zero if the index is not found
  const pollOptionIndex = message.indexOf(
    pollOption
  ) === -1 ? 0 : message.indexOf(pollOption);

  // Find the index of the new line after the poll option
  let newLineAfterPollOptionIndex = message.indexOf("\n", pollOptionIndex);

  // Sets the index of the new line after the poll option to 0
  // if it's not found
  newLineAfterPollOptionIndex =
    newLineAfterPollOptionIndex === -1 ? 0 : newLineAfterPollOptionIndex;

  // Searches for the next double new line in the message slice
  // after the poll option
  let doubleNewLineIndex = message.indexOf(
    "\n\n", newLineAfterPollOptionIndex + 1
  );

  // Set the index for the next double new line to the end of the message
  // if it's not found
  doubleNewLineIndex =
    doubleNewLineIndex === -1 ? message.length : doubleNewLineIndex;

  // Gets the part of the message with the list of names
  const pollOptionSegment = message.slice(
    newLineAfterPollOptionIndex, doubleNewLineIndex
  ).trim();

  // Get the numbering style and the names
  // from the poll option segment
  const matches = Array.from(
    pollOptionSegment.matchAll(numberingStyleAndNameRegex)
  );

  // Initialise the numbering styles variable
  let numberingStyle: string = NUMBERING_STYLES.NONE;

  // Initialise the list of names
  const names: string[] = [];

  // Iterates over the matches
  for (const [index, [ , numStyle, name]] of matches.entries()) {

    // If it's the first item
    if (index === 0) {

      // Set the numbering style
      numberingStyle = numStyle.trim();
    }

    // Add the names to the list of names
    names.push(name);
  }

  // Returns the data for the poll option
  return {
    pollOptionSegment: pollOptionSegment,
    numberingStyle: numberingStyle,
    names: names
  };
}


// Function to create the number of people portion of the poll message.
function createNumberOfPeoplePortion(
  numberOfPeople: number,
  formatOption: FormatOption,
  additionalSubstitutions: { [key: string]: string } = {}
) {

  // Initialise the number format string
  let numberFormatString: string | null | undefined = null;

  // Switch statement to get the correct format string
  switch (numberOfPeople) {

    // The default case, where the number of people
    // is not 0 or 1
    default:
      numberFormatString = formatOption.default;
    break;

    case 0:
      numberFormatString = formatOption.zero;
    break;

    case 1:
      numberFormatString = formatOption.one;
    break;
  }

  // If the number format string is null,
  // set the number format string to the default one
  if (numberFormatString == null) {
    numberFormatString = formatOption.default;
  }

  // Gets the string for the number of people who responded
  const numberOfPeopleString = utils.strFormat(
    numberFormatString,
    { number: numberOfPeople }
  );

  // Returns the header for the poll option
  return utils.bold(
    utils.strFormat(
      formatOption.formatStr,
      { people: numberOfPeopleString, ...additionalSubstitutions }
    )
  )
}


// Function to create the poll portion for a given poll option
export function createPollPortion(
  message: string,
  pollOption: string,
  isSelected: boolean,
  name: string | null,
  formatOption: FormatOption = DEFAULT_FORMAT_OPTIONS.pollOptionHeader
) {

  // Gets the poll option segment of the message
  const { numberingStyle, names } = getPollOptionData(message, pollOption);

  // Initialise the variable to store the list of names
  let listOfNames = names;

  // Initialised the removed variable
  // (the variable to indicate whether the name has been added
  // or removed to the poll option)
  let removed: boolean | null = null;

  // Checks if the poll option is selected and the name is given
  if (isSelected && name) {

    // Checks if the name is included in the list
    if (listOfNames.includes(name)) {

      // Remove the name from the list of names
      listOfNames = listOfNames.filter(personName => personName !== name);

      // Sets the removed variable to true
      removed = true;
    }

    // Otherwise
    else {

      // Adds the name to the list of names
      listOfNames.push(name);

      // Sets the removed variable to false
      removed = false;
    }
  }

  // Create the poll portion for the given poll option
  const pollPortion = `${createNumberOfPeoplePortion(
    listOfNames.length, formatOption, { pollOption: pollOption }
  )}\n${listOfNames.map(
    (name, index) => `${numberingStyle.replace(
      /\d+/, `${index}`
    )} ${name}`.trim()
  ).join("\n")}`;

  // Returns the poll portion
  // and the number of people responded to this poll portion
  return { pollPortion: pollPortion, names: listOfNames, nameRemoved: removed };
}


// Function to reform the poll message
export function reformPollMessage(
  message: string,
  pollMessage: string,
  selectedPollOption: string,
  pollOptions: string[],
  name: string,
  formatOptions: FormatOptions = DEFAULT_FORMAT_OPTIONS
) {

  // The list that contains the final message
  const reformedPollMessageList: string[] = [];

  // The list containing the people who responded to the poll
  let peopleResponded: string[] = [];

  // Initialise the variable to indicate whether the person has been added
  // or removed from the poll
  let removed: boolean | null = null;

  // Adds the poll message and the selected poll portion
  // to the reformed poll message list
  reformedPollMessageList.push(pollMessage);

  // Iterates the list of poll options
  for (const pollOption of pollOptions) {

    // The boolean variable that indicates if the poll option is selected
    const isSelected = pollOption === selectedPollOption;

    // Calls the function to generate the poll portion
    // and get the number of people who responded to that poll option
    const { pollPortion, names, nameRemoved } = createPollPortion(
      message,
      pollOption,
      isSelected,
      isSelected ? name : null,
      formatOptions.pollOptionHeader
    );

    // Adds the poll portion to the reformed poll message list
    reformedPollMessageList.push(pollPortion);

    // Adds the people who responded to the poll option
    // to the list of people who responded
    peopleResponded = peopleResponded.concat(names);

    // If the nameRemoved variable isn't null,
    // then set the removed variable to its value
    if (nameRemoved !== null) removed = nameRemoved;
  }

  // Gets the number of unique people who responded
  const numResponded = new Set(peopleResponded).size;

  // The portion of the message that says how many people responded
  const respondedPortion = createNumberOfPeoplePortion(
    numResponded, formatOptions.messageFooter
  );

  // Adds the responded portion to the reformed message list
  reformedPollMessageList.push(respondedPortion);

  // Reform the poll message
  const reformedPollMessage = reformedPollMessageList.join("\n\n");

  // Returns the reformed poll message
  return { reformedPollMessage: reformedPollMessage, removed: removed };
}


// Function to get the name of the user
export function getName(user: User) {
  return `${user.first_name} ${user.last_name ?? ""}`.trim();
}


// Function to get the list of poll options
export function getPollOptions(inline_keyboard: InlineKeyboardButton[][]) {

  // The list of poll options
  const pollOptions = [];

  // Iterates the list of inline keyboard buttons
  for (const inlineKeyboardButton of inline_keyboard) {

    // Gets the text for the inline keyboard button
    const text = inlineKeyboardButton[0].text;

    // Adds the text to the list of poll options
    pollOptions.push(text);
  }

  // Returns the list of poll options
  return pollOptions;
}


// Function to get the poll message
export function getPollMessage(message: string, pollOptions: string[]) {

  // Gets the index of the first poll option in the message
  const firstPollOptionIndex = message.indexOf(pollOptions[0]);

  // Returns the poll message with the first line bolded
  return utils.boldFirstLine(message.slice(0, firstPollOptionIndex).trim());
}


// Function to handle a callback query
export async function callback_handler(
  ctx: Scenes.WizardContext,
  pollType: PollType = POLL_TYPES.DEFAULT
) {

  // Gets the callback query object
  const callbackQuery = ctx.callbackQuery as CbQuery;

  // Cast the callback query message type
  const message = callbackQuery.message;

  // Gets the message text
  const messageText = message.text;

  // If the poll type isn't found in the message,
  // immediately exit the function so that
  // another handler can take care of the message
  if (!messageText.includes(pollType)) return;

  // Gets the poll option and the poll message
  const pollOption = callbackQuery.data;

  // If the poll option doesn't exist, then tells the user
  if (messageText.indexOf(pollOption) === -1) return await ctx.answerCbQuery(
    `The option "${
      pollOption
    }" doesn't exist on the poll you are responding to.`
  );

  // Gets the list of poll options
  const pollOptions = getPollOptions(message.reply_markup.inline_keyboard);

  // Gets the poll message
  const pollMessage = getPollMessage(messageText, pollOptions);

  // Gets the name of the person responding
  const name = getName(callbackQuery.from);

  // Gets the reformed poll message
  // and the variable to indicated whether the person has been added
  // or removed from the poll option
  const { reformedPollMessage, removed } = reformPollMessage(
    messageText,
    pollMessage,
    pollOption,
    pollOptions,
    name
  );

  // Answers the callback query
  await ctx.answerCbQuery(
    `Your name has been ${removed ? "removed from" : "added to"
    } '${pollOption}'!`
  );

  // Edit the message with the reformed poll message
  return await ctx.editMessageText(reformedPollMessage, {
    parse_mode: "HTML",
    reply_markup: {
      inline_keyboard: message.reply_markup.inline_keyboard
    }
  });
}
