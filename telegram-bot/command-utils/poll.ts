// The utility functions for the poll command

import type {
  User,
  InlineKeyboardButton,
  Message,
} from "telegraf/types";
import type {
  CbQuery,
  ObjectValues,
  InlineKeyboardGenerator
} from "../types";
import { Scenes, Composer, Markup } from "telegraf";
import * as filters from "telegraf/filters";
import * as utils from "../utils";
import {
  cancelCommand,
  deleteMessages,
  promptUserForInput,
  removeBotUsernameAndCommand,
  generateInlineKeyboard,
  generateReplyKeyboard,
  callStep,
  markMessageForDeletion
} from "../bot-utils"


// The constant representing the standard spacing to be used
// in the poll message
const POLL_SPACING = "\n\n";

// The enum representing the various poll types
export const POLL_TYPES = {
  DEFAULT: utils.generateZeroWidthCode("default"),
  RENTAL: utils.generateZeroWidthCode("rental"),
} as const;

// The type of poll
export type PollType = ObjectValues<typeof POLL_TYPES>;

// The enum representing the numbering styles for the poll
export const NUMBERING_STYLES = {
  NONE: "",
  DASH: "-",
  ARROWHEAD: ">",
  EQUAL: "=",
  PLUS: "+",
  TILDE: "~",
  SMALL_DOT: "Â·",
  BIG_DOT: "â€¢",
  ROUND_BRACKET: "1)",
  NUMBERED_DOT: "1.",
  ROUND_BRACKETS: "(1)",
  SQUARE_BRACKETS: "[1]",
  CURLY_BRACKETS: "{1}",
  ANGLE_BRACKETS: "<1>",
} as const;

// The default numbering style
export const DEFAULT_NUMBERING_STYLE = NUMBERING_STYLES.NONE;

// The default option for whether or not to preserve
// the number of lines in the poll message
export const DEFAULT_PRESERVE_LINES = false;

// The default option for whether or not to show the
// the remaining number of open slots in the poll message
export const DEFAULT_SHOW_REMAINING = false;

// The default option for whether or not
// to tag all occurences of an entry in the poll message
export const DEFAULT_TAG_ALL = false;

// The regex to get the numbering style from the poll option segment
const numberingStyleRegex = /[->=+~â€¢Â·([{<]?\d*[).\]}>]?/;

// The regex to get the numbering style
// and the name from the poll option segment.
// The [^\S\r\n] group matches all spaces except for new line characters,
// which is what we want here
const numberingStyleAndNameRegex = new RegExp(
  String.raw`^[^\S\r\n]*?(${
    numberingStyleRegex.source
  })[^\S\r\n]*(.*?)[^\S\r\n]*()$`,
  "gm"
);

// The regex to create the numbering from the numbering style
const createNumberingRegex = /\d+/;

// The regex to get the maximum number of entries from the
// poll option header.
// The [^\S\r\n] group matches all spaces except for new line characters,
// which is what we want here
const getMaxEntriesRegex = /\d+[^\S\r\n]*\/[^\S\r\n]*(\d+)/;

// The type for the numbering styles
export type NumberingStyle = ObjectValues<typeof NUMBERING_STYLES>;

// The default poll options
export const DEFAULT_POLL_OPTIONS = ["Coming"];

// The type of the format option variable
export type FormatOption = {
  formatStr: string,
  bold: boolean,
  default: string,
  zero?: string | null,
  one?: string | null
}

// The type of the format options variable
export type FormatOptions = {
  pollOptionHeader: FormatOption,
  messageFooter: FormatOption
}

// The default format options
export const DEFAULT_FORMAT_OPTIONS: FormatOptions = {

  // The {people} in the formatStr property will be substituted
  // with the string generated by substituting the zero, one, and
  // moreThanOne properties.

  // The {number} in the zero, one and default properties
  // will be substituted with the actual number of people who
  // responded to the poll option.

  // The {maxEntries} in the zero, one and defulat properties
  // will be substituted with the maximum number of people
  // allowed on that particular poll option

  // The options for the individual options of the poll
  pollOptionHeader: {

    // The format string for the header of a single poll option
    // The {pollOption} in the formatStr will be substituted with
    // the poll option.
    // The formatStr should start with the poll option,
    // otherwise the callback query won't work unless the regular expression
    // in the getPollOptionSegment function is changed as the current
    // regular expression matches from the start of the line.
    formatStr: "{pollOption} {people}",

    // Whether to bold the header or not.
    // The poll option header should be bolded.
    bold: true,

    // The string to display when there is more than one person.
    // This is also the string that will be used if no string is given
    // for zero and one.
    default: "({number}ðŸ‘¥)",

    // The string to display when there is no one
    zero: "",

    // The string to display when there is one person
    one: null
  },

  // The options for the message footer
  messageFooter: {

    // The format string for the header of the poll message.
    formatStr: "ðŸ‘¥ {people} responded",

    // Whether to bold the message footer or not.
    // The message footer should not be bolded.
    bold: false,

    // The string to display when there is more than one person.
    // This is also the string that will be used if no string is given
    // for zero and one.
    default: "{number} people",

    // The string to display when there is no one
    zero: "Nobody",

    // The string to display when there is one person
    one: "1 person"
  }
} as const;


// Function to create the numbering from the numbering style
function createNumbering(numberingStyle: string, index: number) {
  return numberingStyle.replace(createNumberingRegex, `${index + 1}`);
}


// Function to create the number of people portion of the poll message.
function createNumberOfPeoplePortion(
  numberOfPeople: number,
  formatOption: FormatOption,
  additionalSubstitutions: { [key: string]: string } = {},
  maxEntries: number | null = null,
  showRemaining: boolean = false,
) {

  // Initialise the number format string
  let numberFormatString: string | null | undefined = null;

  // Switch statement to get the correct format string
  switch (numberOfPeople) {

    // The default case, where the number of people
    // is not 0 or 1
    default:
      numberFormatString = formatOption.default;
    break;

    case 0:
      numberFormatString = formatOption.zero;
    break;

    case 1:
      numberFormatString = formatOption.one;
    break;
  }

  // If the number format string is null,
  // set the number format string to the default one
  if (numberFormatString == null) {
    numberFormatString = formatOption.default;
  }

  // Gets the format arguments
  const formatArgs: { [key: string]: number } = { number: numberOfPeople };

  // If the maximum number of entries is given and is not infinity
  if (Number.isFinite(maxEntries)) {

    // Cast the maxEntries variable to a number.
    // For some reason typescript just doesn't understand
    // the above check also checks for null and undefined
    // and will return false in those cases
    maxEntries = maxEntries as number;

    // Add the maxEntries variable to the format arguments
    formatArgs["maxEntries"] = maxEntries;

    // If the number of remaining slots on the poll option is wanted
    if (showRemaining) {

      // Set the number to the number of remaining slots
      formatArgs["number"] = maxEntries - numberOfPeople;
    }
  }

  // Gets the string for the number of people who responded
  const numberOfPeopleString = utils.strFormat(
    numberFormatString,
    formatArgs
  );

  // Gets the number of people portion of the poll message
  const numberOfPeoplePortion = utils.strFormat(
    formatOption.formatStr,
    { people: numberOfPeopleString, ...additionalSubstitutions }
  ).trim();

  // Returns the number of people portion of the poll message
  // and bold it if it is needed
  return formatOption.bold ? utils.bold(
    numberOfPeoplePortion
  ) : numberOfPeoplePortion;
}


// Function to create the poll portion of the poll message
export function createPollPortion(
  pollOptions: string[],
  maxEntriesList: number[] = [],
  numberingStyle: NumberingStyle = DEFAULT_NUMBERING_STYLE,
  formatOptions: FormatOptions = DEFAULT_FORMAT_OPTIONS,
  preserveLines: boolean = DEFAULT_PRESERVE_LINES,
  showRemaining: boolean = DEFAULT_SHOW_REMAINING
) {

  // The list to contain the strings in the poll portion
  const pollPortionList: string[] = [];

  // Iterates over all the poll options
  for (const [index, pollOption] of pollOptions.entries()) {

    // The list containing the lines in the poll option
    // The first line is the poll option header
    const pollOptionLines: string[] = [];

    // Gets the max entries for the poll option
    const maxEntries = maxEntriesList[index] ?? 0;

    // If the numbering style is present,
    // and the maximum number of entries less than 1,
    // or the lines are to be preserved.
    // This is to generate one empty line with the numbering style
    // so that the callback query knows what numbering style is being used
    if (numberingStyle && maxEntries < 1 || preserveLines) {

      // Set the maximum number of lines to the maximum number of entries
      // unless the maximum number of entries is less than 1,
      // then the maximum number of lines is set to 1.
      const maxNumberOfLines = maxEntries < 1 ? 1 : maxEntries;

      // Iterates until the maximum number of lines is hit
      for (let i = 0; i < maxNumberOfLines; ++i) {

        // Add the numbering style to the list of poll option lines
        pollOptionLines.push(`${createNumbering(numberingStyle, i)}`);
      }
    }


    // Create the poll option header
    const pollOptionHeader = createNumberOfPeoplePortion(
      0,
      formatOptions.pollOptionHeader,
      { pollOption: pollOption },
      maxEntries,
      showRemaining
    );

    // Adds the lines in the poll option to the list
    pollPortionList.push(
      `${pollOptionHeader}\n${
        utils.stripHtml(pollOptionLines.join("\n"))
      }`
    );
  }

  // Returns the poll portion
  return `${pollPortionList.join(POLL_SPACING)}${POLL_SPACING}${
    createNumberOfPeoplePortion(
      0, formatOptions.messageFooter
    )
  }`.trim();
}


// Function to generate the callback function for the poll message command
export function generatePollMessage(
  message: string,
  pollOptions: string[] = DEFAULT_POLL_OPTIONS,
  maxEntriesList: number[] = [],
  numberingStyle: NumberingStyle = DEFAULT_NUMBERING_STYLE,
  formatOptions: FormatOptions = DEFAULT_FORMAT_OPTIONS,
  preserveLines: boolean = DEFAULT_PRESERVE_LINES,
  showRemaining: boolean = DEFAULT_SHOW_REMAINING,
  pollType: PollType = POLL_TYPES.DEFAULT,
  inlineKeyboardGenerator: InlineKeyboardGenerator = generateInlineKeyboard
) {

  // Remove the command and the bot's username from the message
  message = removeBotUsernameAndCommand(message);

  // Generate the portion of the message that is a poll
  const pollPortion = createPollPortion(
    pollOptions,
    maxEntriesList,
    numberingStyle,
    formatOptions,
    preserveLines,
    showRemaining
  );

  // Create the inline keyboard
  const inlineKeyboard = inlineKeyboardGenerator(pollOptions);

  // The callback function
  async function callback(ctx: Scenes.WizardContext, input: string) {

    // Bold the first line of the input
    input = utils.boldFirstLine(input);

    // Sends a poll with the user's input
    return await ctx.reply(
      `${input}${pollType}${POLL_SPACING}${pollPortion}`,
      {
        parse_mode: "HTML",
        ...inlineKeyboard
      }
    );
  }

  // Returns the message and the callback function
  return { userMessage: message, callback: callback };
}










// All functions relating to the callback query from the poll


// Function to get the index or a default value
// if the index is not found (indexOf returns -1 if not found).
// It is like the dictionary.get function in python,
// but with message indexes
function getIndexOrDefaultValue(
  index: number,
  defaultValue: number = 0
) {
  return index === -1 ? defaultValue : index;
}


// Function to get the poll option segment
export function getPollOptionSegment(message: string, pollOption: string) {

  // Gets the index of the poll option in the message
  // and set it to zero if the index is not found.
  // For now, I think it's okay to have it match from
  // the beginning of the line, as I don't intend
  // to have the format string have anything before the
  // poll option.
  const pollOptionIndex = message.match(
    new RegExp(String.raw`^\b${pollOption}\b`, "m")
  )?.index ?? 0;

  // Initialise the variable to store the index of the
  // new line before the poll option segment
  let newLineBeforePollOptionIndex = 0;

  // Iterates backwards from the poll option index
  for (let index = pollOptionIndex; index > 0; --index) {

    // If the character is not a new line character,
    // continue the loop
    if (message[index] !== "\n") continue;

    // Otherwise, set the index of the new line before the poll option
    newLineBeforePollOptionIndex = index;

    // Breaks out of the loop
    break;
  }

  // Find the index of the new line after the poll option
  const newLineAfterPollOptionIndex = getIndexOrDefaultValue(
    message.indexOf("\n", pollOptionIndex), 0
  );

  // Gets the entire line that the poll option is on
  const pollOptionLine = message.slice(
    newLineBeforePollOptionIndex + 1,
    newLineAfterPollOptionIndex
  );

  // Searches for the next double new line in the message slice
  // after the poll option
  const doubleNewLineIndex = getIndexOrDefaultValue(
    message.indexOf("\n\n", newLineAfterPollOptionIndex + 1), message.length
  );

  // Gets the part of the message with the list of names
  const pollOptionNameSegment = message.slice(
    newLineAfterPollOptionIndex, doubleNewLineIndex
  ).trim();

  // Returns the name part of the poll option segment
  return {
    pollOptionNameSegment: pollOptionNameSegment,
    pollOptionLine: pollOptionLine
  };
}


// Function to get the maximum number of entries for a poll option
function getPollOptionMaxEntries(pollOptionLine: string) {

  // Search for the maximum entries in line containing the poll option
  const match = pollOptionLine.match(getMaxEntriesRegex);

  // Gets the max entries for the poll from the match.
  // The regex.match function returns null if no match is found,
  // so returning an array with two null values instead of null allows
  // the destructuring to still work.
  const [ , maxEntries] = match ?? [null, null];

  // Returns the maximum number of entries that has been gotten from
  // the poll option line.
  // If the maximum number of entries isn't found,
  // which means maxEntries is null, then return infinity for no limit
  return maxEntries == null ? Infinity : parseInt(maxEntries);
}


// Function to regenerate the poll portion for a given poll option
export function regeneratePollPortion(
  message: string,
  pollOption: string,
  selected: boolean,
  givenName: string | null,
  formatOption: FormatOption = DEFAULT_FORMAT_OPTIONS.pollOptionHeader,
  preserveLines: boolean = DEFAULT_PRESERVE_LINES,
  showRemaining: boolean = DEFAULT_SHOW_REMAINING,
  tagString: string | null = null,
) {

  // Gets the poll option segment of the message
  const {
    pollOptionNameSegment, pollOptionLine
  } = getPollOptionSegment(message, pollOption);

  // Get the maximum number of entries from the poll option line
  const maxEntries = getPollOptionMaxEntries(pollOptionLine);

  // Initialise the regular expression to the
  // globally defined numbering style and name regex
  let regex = numberingStyleAndNameRegex;

  // If the tag string is given
  if (tagString) {

    // Escape all the characters in the tag string
    const escapedTagString = Array.from(tagString).map(
      char => `\\${char}`
    ).join("");

    // Recreate the regular expression to add the tag string
    regex = new RegExp(
      `${numberingStyleAndNameRegex.source.replace(
        /\(\)\$$/, `((?:${escapedTagString})?)$`
      )}`,
      numberingStyleAndNameRegex.flags
    );
  }

  // Get the numbering style and the names
  // from the poll option segment
  const matches = Array.from(
    pollOptionNameSegment.matchAll(regex)
  );

  // Initialise the numbering styles variable
  let numberingStyle: string = DEFAULT_NUMBERING_STYLE;

  // Initialise the encountered variable
  // to indicate whether the given name has been
  // encountered or not
  let encountered = false;

  // Initialised the removed variable
  // This variable indicates whether the name has been added
  // or removed to the poll option, and a null value means that
  // the person failed to be added to the list.
  let removed: boolean | null = null;

  // Initialise the tagged variable
  // This variable indicates whether
  // the name has been tagged or not.
  // If the value is null,
  // that means the person's name
  // hasn't been added to the list.
  let tagged: boolean | null = null;

  // Initialise the list of string to get the poll portion
  const pollPortionList: string[] = [];

  // Initialise the list of names
  const names: string[] = [];

  // Iterates over the matches
  for (const [index, [ , numStyle, name, tag]] of matches.entries()) {

    // If it's the first item
    if (index === 0) {

      // Set the numbering style
      numberingStyle = numStyle
    }

    // Gets the trimmed name
    const trimmedName = name.trim();

    // If the name is empty, continue the loop
    if (!trimmedName) continue;

    // Create the numbering
    const numbering = createNumbering(numberingStyle, index);

    // Otherwise, if the name is selected and the name is the given name
    if (trimmedName === givenName && selected) {

      // Set the encountered variable to true
      encountered = true;

      // If the tag string is given
      if (tagString) {

        // Sets the tagged variable
        tagged = tag ? true : false;

        // Add or remove the tag depending on whether the tag is already there
        // and add the string to the poll portion list
        pollPortionList.push(
          `${numbering} ${trimmedName} ${tag ? "" : tagString}`.trim()
        );
      }

      // Otherwise, if no tag string is given
      else {

        // Set the removed variable to true
        removed = true;

        // Continue the loop to remove the name from the list
        continue;
      }
    }

    // Otherwise, if the name is not the given name
    else {

      // Adds the numbering style, name, and the tag
      // to the poll portion list
      pollPortionList.push(`${numbering} ${trimmedName} ${tag}`);
    }

    // Add the name to the list of names
    names.push(trimmedName);
  }

  // The condition to add the person to the poll message.
  // Which is that the poll option must be selected,
  // the name must be given,
  // the name must not have been encountered earlier when iterating through
  // the list of people for the poll option,
  // the name is not being tagged as
  // the absence of a tag string means tagging isn't wanted and
  // the length of the list of names must be less than
  // the maximum number of entries.
  // Tagging should not be done as the person should already be
  // in the list to be tagged.
  const canAddToPoll = (
    selected
    && givenName
    && !encountered
    && !tagString
    && names.length < maxEntries
  );

  // If all the conditions to add the person to the poll message
  // are fulfilled.
  if (canAddToPoll) {

    // Set the removed variable to false,
    // which means the person has been added to the list
    // The removed variable being null means the person
    // failed to be added to the poll.
    removed = false;

    // Adds the given name to the list
    // This is done first as the createNumbering function
    // increases the given index by 1
    pollPortionList.push(
      `${createNumbering(numberingStyle, names.length)} ${givenName}`
    );

    // Adds the name to the list of names
    names.push(givenName);
  }

  // If the numbering style is not NONE,
  // and there are no names on the poll option,
  // or if the lines in the poll message should be preserved
  if (numberingStyle && names.length < 1 || preserveLines) {

    // Set the maximum number of lines to the maximum number of entries.
    // If the maximum number of entries is infinity, then set the
    // maximum number of entries to 0, as there's no maximum.
    // The preserve lines option is to preserve the number of lines
    // when there is a limit on the number of people for the poll.
    // It wouldn't make sense to keep on increasing the number of lines,
    // especially if people remove their names from the poll,
    // as the lines will still be there.
    let maxNumberOfLines = Number.isFinite(maxEntries) ? maxEntries : 0;

    // If the maximum number of lines is less than 1,
    // and there is no one left on the poll,
    // then set the maximum number of lines to 1.
    // This is so that the numbering style can still be preserved
    // even when there are no names on the poll
    if (maxNumberOfLines < 1 && names.length < 1) maxNumberOfLines = 1;

    // Iterates from the number of people to the maximum number of lines
    for (let index = names.length; index < maxNumberOfLines; ++index) {

      // Adds the numbering to the list
      pollPortionList.push(`${createNumbering(numberingStyle, index)}`);
    }
  }

  // Gets the poll portion header
  const pollPortionHeader = createNumberOfPeoplePortion(
    names.length,
    formatOption,
    { pollOption: pollOption },
    maxEntries,
    showRemaining
  );

  // Create the poll portion for the given poll option
  const pollPortion = `${pollPortionHeader}\n${
    utils.stripHtml(pollPortionList.join("\n").trim())
  }`;

  // Returns the poll portion
  // and the number of people responded to this poll portion
  return {
    pollPortion: pollPortion,
    names: names,
    nameRemoved: removed,
    nameTagged: tagged
  };
}


// Function to reform the poll message
export function reformPollMessage(
  message: string,
  pollMessage: string,
  selectedPollOption: string,
  pollOptions: string[],
  name: string,
  formatOptions: FormatOptions = DEFAULT_FORMAT_OPTIONS,
  preserveLines: boolean = DEFAULT_PRESERVE_LINES,
  showRemaining: boolean = DEFAULT_SHOW_REMAINING,
  tagString: string | null = null,
  tagAll: boolean = DEFAULT_TAG_ALL
) {

  // The list that contains the final message
  const reformedPollMessageList: string[] = [];

  // The list containing the people who responded to the poll
  let peopleResponded: string[] = [];

  // Initialise the variable to indicate whether the person has been added
  // or removed from the poll
  let removed: boolean | null = null;

  // Initiliase the variable to indicate whether the name has been
  // tagged or untagged on the poll
  let tagged: boolean | null = null;

  // Adds the poll message and the selected poll portion
  // to the reformed poll message list
  reformedPollMessageList.push(pollMessage);

  // Iterates the list of poll options
  for (const pollOption of pollOptions) {

    // The boolean variable that indicates if the poll option is selected
    let isSelected = pollOption === selectedPollOption;

    // If the tag string is given,
    // and all of the entries should be tagged,
    // then indicate that the poll option is selected
    if (tagAll && tagString) isSelected = true;

    // Calls the function to generate the poll portion
    // and get the number of people who responded to that poll option
    const {
      pollPortion,
      names,
      nameRemoved,
      nameTagged
    } = regeneratePollPortion(
      message,
      pollOption,
      isSelected,
      isSelected ? name : null,
      formatOptions.pollOptionHeader,
      preserveLines,
      showRemaining,
      tagString
    );

    // Adds the poll portion to the reformed poll message list
    reformedPollMessageList.push(pollPortion);

    // Adds the people who responded to the poll option
    // to the list of people who responded
    peopleResponded = peopleResponded.concat(names);

    // If the nameRemoved variable isn't null,
    // then set the removed variable to its value
    if (nameRemoved != null) removed = nameRemoved;

    // If the nameTagged variable isn't null,
    // then set the tagged variable to its value
    if (nameTagged != null) tagged = nameTagged;

    console.log(`removed is ${removed}`)
    console.log(`tagged is ${tagged}`)
  }

  // Gets the number of unique people who responded
  const numResponded = new Set(peopleResponded).size;

  // The portion of the message that says how many people responded
  const respondedPortion = createNumberOfPeoplePortion(
    numResponded, formatOptions.messageFooter
  );

  // Adds the responded portion to the reformed message list
  reformedPollMessageList.push(respondedPortion);

  // Reform the poll message
  const reformedPollMessage = reformedPollMessageList.join(POLL_SPACING);

  // Returns the reformed poll message
  return {
    reformedPollMessage: reformedPollMessage.trim(),
    removed: removed,
    tagged: tagged
  };
}


// Function to get the name of the user
export function getName(user: User) {
  return `${user.first_name} ${user.last_name ?? ""}`.trim();
}


// Function to get the list of poll options
export function getPollOptions(inlineKeyboard: InlineKeyboardButton[][]) {

  // The list of poll options
  const pollOptions = [];

  // Iterates the list of inline keyboard buttons
  for (const inlineKeyboardButton of inlineKeyboard) {

    // Gets the text for the inline keyboard button
    const text = inlineKeyboardButton[0].text;

    // Adds the text to the list of poll options
    pollOptions.push(text);
  }

  // Returns the list of poll options
  return pollOptions;
}


// Function to get the poll message
export function getPollMessage(message: string, pollOptions: string[]) {

  // Gets the index of the first poll option in the message
  const firstPollOptionIndex = message.indexOf(pollOptions[0]);

  // Returns the poll message with the first line bolded
  return utils.boldFirstLine(message.slice(0, firstPollOptionIndex).trim());
}


// Function to handle a callback query
export async function callback_handler(
  ctx: Scenes.WizardContext,
  next: () => Promise<void>
) {

  // Gets the callback query object
  const callbackQuery = ctx.callbackQuery as CbQuery;

  // Get the message from the callback query
  const message = callbackQuery.message;

  // Gets the message text
  const messageText = message.text;

  // If the poll type isn't found in the message,
  // calls the next() function and
  // immediately exit the function so that
  // another handler can take care of the message
  if (!messageText.includes(POLL_TYPES.DEFAULT)) return await next();

  // Gets the poll option and the poll message
  const pollOption = callbackQuery.data;

  // If the poll option doesn't exist, then tells the user
  if (messageText.indexOf(pollOption) === -1) {
    return await ctx.answerCbQuery(
      `The option "${
        pollOption
      }" doesn't exist on the poll you are responding to.`
    );
  }

  // Gets the list of poll options
  const pollOptions = getPollOptions(message.reply_markup.inline_keyboard);

  // Gets the poll message
  const pollMessage = getPollMessage(messageText, pollOptions);

  // Gets the name of the person responding
  const name = getName(callbackQuery.from);

  // Gets the reformed poll message
  // and the variable to indicated whether the person has been added
  // or removed from the poll option
  const { reformedPollMessage, removed } = reformPollMessage(
    messageText,
    pollMessage,
    pollOption,
    pollOptions,
    name,
    DEFAULT_FORMAT_OPTIONS,
    DEFAULT_PRESERVE_LINES,
    DEFAULT_SHOW_REMAINING
  );

  // Answers the callback query
  await ctx.answerCbQuery(
    `Your name has been ${
      removed ? "removed from" : "added to"
    } '${pollOption}'!`
  );

  // Edit the message with the reformed poll message
  return await ctx.editMessageText(reformedPollMessage, {
    parse_mode: "HTML",
    reply_markup: {
      inline_keyboard: message.reply_markup.inline_keyboard
    }
  });
}










// Scenes for the poll message

// The type for a step in the create poll message scene
export type CreatePollMessageContext = Scenes.WizardContext & {
  message: Message.TextMessage
}

// The type of the additional options function
export type AdditionalOptionsFunction = (
  ctx: CreatePollMessageContext,
  message: string,
  state: CreatePollMessageState
) => Promise<boolean>


// The type of the list of prompts for the create poll message scene
export type CreatePollMessagePrompts = [
  string,
  {
    success: string,
    failure: {
      prompt: string,
      placeholder: string
    }
  },
  { success: string, failure: string }
];


// The type for the create poll message state
type CreatePollMessageState = {
  prompts: CreatePollMessagePrompts,
  pollMessage: string,
  pollOptions: string[],
  maxEntriesList?: number[],
  numberingStyle?: NumberingStyle,
  formatOptions?: FormatOptions,
  preserveLines?: boolean,
  showRemaining?: boolean,
  pollType?: PollType,
  inlineKeyboardGenerator?: InlineKeyboardGenerator,
  additionalOptionsFuncList?: AdditionalOptionsFunction[],
  additionalOptionsIndex?: number,
  messagesToDelete?: number[]
};

// The type for the configuration options for the create poll message scene
export type CreatePollMessageConfig = Omit<
  CreatePollMessageState, "pollMessage" | "pollOptions"
>;


// The scene name for the create poll message scene
const sceneName = "createPollMessage";


// The incomplete data message for the poll message creation scene
const incompleteDataMessage = `The poll message is still missing some required data for it to be generated.

Please continue the poll message creation process or use the /cancel command to cancel the creation of the poll message.`;


// The poll option message
const pollOptionMsg = `Please enter another poll option.

Use the /done command to get the bot to send the poll message.`;


// The default list of prompts for the poll message scene
export const DEFAULT_CREATE_POLL_MESSAGE_PROMPTS: CreatePollMessagePrompts = [

  // The prompt for the first step
  "Please enter the message for the poll.",

  // The prompts for the second step
  {
    success: "Please enter the first poll option.",
    failure: {
      prompt: "Please choose a numbering style from the list.",
      placeholder: "Choose a numbering style..."
    },
  },

  // The prompts for the third step
  { success: pollOptionMsg, failure: "Please enter a poll option." }
] as const;


// The default poll message configuration
export const DEFAULT_CREATE_POLL_MSG_CONFIG: CreatePollMessageConfig = {
  prompts: DEFAULT_CREATE_POLL_MESSAGE_PROMPTS,
  formatOptions: DEFAULT_FORMAT_OPTIONS,
  preserveLines: false,
  showRemaining: false,
  pollType: POLL_TYPES.DEFAULT,
  inlineKeyboardGenerator: generateInlineKeyboard
};


// The regex to get the numbering style from the string
// generated from the createNumberingStylesList function
const getNumberingStyleFromStringRegex = /^[A-Za-z_ ]+/;


// The function to handle the done command
async function doneCommandHandler(ctx: Scenes.WizardContext) {

  // Gets the state object
  const state = ctx.wizard.state as CreatePollMessageState;

  // If the message or poll options are not given
  if (!state.pollMessage || Object.keys(state.pollOptions).length <= 0) {

    // Tells the user that the poll message is not completed
    // and they should use the "/cancel" command instead to cancel
    // the operation.
    // Also, exit the function
    return await promptUserForInput(ctx, incompleteDataMessage);
  }

  // Otherwise, mark the user's message for deletion
  markMessageForDeletion(ctx, ctx.message!.message_id);

  // Create the poll message
  const { userMessage, callback } = generatePollMessage(
    state.pollMessage,
    state.pollOptions ?? DEFAULT_POLL_OPTIONS,
    state.maxEntriesList ?? [],
    state.numberingStyle ?? DEFAULT_NUMBERING_STYLE,
    state.formatOptions ?? DEFAULT_FORMAT_OPTIONS,
    state.preserveLines ?? DEFAULT_PRESERVE_LINES,
    state.showRemaining ?? DEFAULT_SHOW_REMAINING,
    state.pollType ?? POLL_TYPES.DEFAULT,
    state.inlineKeyboardGenerator ?? generateInlineKeyboard
  );

  // Calls the callback to send the poll message
  await callback(ctx, userMessage);

  // Delete all the messages sent by the user
  await deleteMessages(
    ctx, ...(state.messagesToDelete ?? [])
  );

  // Exit the scene
  await ctx.scene.leave();
}


// Function to create a step in the poll message scene
function createStep(
  func: (
    ctx: Scenes.WizardContext,
    next: () => Promise<void>
  ) => Promise<unknown>
) {

  // Create a new composer
  const composer = new Composer<Scenes.WizardContext>();

  // Attach the cancel command handler
  composer.command(...cancelCommand);

  // Attach the done command handler
  composer.command("done", doneCommandHandler);

  // Attach the function as the main handler
  composer.on(filters.message("text"), func);

  // Returns the composer
  return composer;
}


// The function to create a list of numbering styles as a string
// from the numbering style constant
export function createNumberingStylesList() {

  // The list of numbering styles to
  // pass to the createReplyKeyboard function
  const numberingStyles: string[] = [];

  // Iterate over the numbering style constant
  for (const [property, value] of Object.entries(NUMBERING_STYLES)) {

    // Replace the underscores with a space
    let propertyStr = property.replaceAll("_", " ").trim();

    // Titlecase the property string
    propertyStr = utils.titlecase(propertyStr);

    // Adds the property string
    // and the value to the list of numbering styles
    numberingStyles.push(`${propertyStr} ${value}`.trim());
  }

  // Returns the list of numbering styles
  return numberingStyles;
}


// The function to get the numbering style from the string
// created by the createNumberingStylesList function
export function getNumberingStyleFromString(str: string) {
  return str.replace(
    getNumberingStyleFromStringRegex, ""
  ).trim() as NumberingStyle;
}


// The create poll message scene
export const createPollMessageScene = new Scenes.WizardScene(

  // The scene name
  sceneName,

  // The first step to get the poll message
  createStep(
    async (context: Scenes.WizardContext, next: () => Promise<void>) => {

      // Cast the context to the correct type
      const ctx = context as CreatePollMessageContext;

      // Gets the state object
      const state = ctx.wizard.state as CreatePollMessageState;

      // Set the poll options in the state if it has not been initialised
      state.pollOptions = state.pollOptions ?? [];

      // If the message is already given
      if (state.pollMessage) {

        // Calls the next function in the scene
        // and exit the function
        return await callStep(ctx, next);
      }

      // Otherwise, gets the message sent by the user
      let message = ctx.message.text;

      // Gets the message text from the message
      message = removeBotUsernameAndCommand(message);

      // If the message is empty
      if (!message) {

        // Prompt the user for input with the first prompt.
        // Zero is the first prompt due to zero indexing
        return await promptUserForInput(
          ctx,
          state.prompts[0]
        );
      }

      // Otherwise
      else {

        // Save the message to the state
        state.pollMessage = message;

        // Calls the next function in the scene
        // and exit the function
        return await callStep(ctx, next);
      }
    }
  ),

  // The second step to get the numbering style
  createStep(
    async (context: Scenes.WizardContext) => {

      // Cast the context to the correct type
      const ctx = context as CreatePollMessageContext;

      // Gets the state object
      const state = ctx.wizard.state as CreatePollMessageState;

      // Gets the message from the user
      let message = ctx.message.text;

      // Remove the command and the bot's username from the message
      message = removeBotUsernameAndCommand(message);

      // Gets the list of numbering styles
      const numberingStyles = createNumberingStylesList();

      // Gets the prompts for this step
      // 1 means the second step thanks to zero indexing
      const prompts = state.prompts[1];

      // If the message is not one of the accepted numbering styles
      if (!numberingStyles.includes(message)) {

        // Tells the user to enter a valid numbering style
        // and exit the function
        return await promptUserForInput(
          ctx,
          prompts.failure.prompt,
          {
            ...generateReplyKeyboard(
              numberingStyles,
              {
                oneTime: true,
                resize: true,
                placeholder: prompts.failure.placeholder
              }
            ),
          }
        );
      }

      // Otherwise
      else {

        // Save the numbering style to the state
        state.numberingStyle = getNumberingStyleFromString(message);

        // Gets the user to send the first poll option
        await promptUserForInput(
          ctx,
          prompts.success,
          { ...Markup.removeKeyboard() }
        );

        // Go to the next function in the scene
        return ctx.wizard.next();
      }
    }
  ),

  // The third step to get the poll options
  createStep(
    async (context: Scenes.WizardContext, next: () => Promise<void>) => {

      // Cast the context to the correct type
      const ctx = context as CreatePollMessageContext;

      // Gets the state object
      const state = ctx.wizard.state as CreatePollMessageState;

      // Gets the message from the user
      let message = ctx.message.text;

      // Gets the message text from the message
      message = removeBotUsernameAndCommand(message);

      console.log(message);

      // Gets the prompts for this step
      // 2 is the 3rd step because of zero indexing
      const prompts = state.prompts[2];

      // If the message is empty
      if (!message) {

        // Tells the user to enter a poll option
        // and exit the function
        return await promptUserForInput(
          ctx,
          prompts.failure
        );
      }

      // Otherwise
      else {

        // Save the poll option to the state
        state.pollOptions.push(message);

        // If the there are no additional options
        if (!state.additionalOptionsFuncList?.length) {

          // Tells the user to enter another poll option
          // and exit the function
          return await promptUserForInput(
            ctx,
            prompts.success
          );
        }

        // Otherwise, set the additional options index to 0
        state.additionalOptionsIndex = 0;

        // Calls the function in the next step
        return await callStep(ctx, next);
      }
    }
  ),

  // The fourth step in creating the poll message
  // which is to get all the additional options if there are any
  createStep(
    async (context: Scenes.WizardContext, next: () => Promise<void>) => {

      // Cast the context to the correct type
      const ctx = context as CreatePollMessageContext;

      // Gets the state object
      const state = ctx.wizard.state as CreatePollMessageState;

      // Set the additional options index if it hasn't been set yet
      state.additionalOptionsIndex = state.additionalOptionsIndex ?? 0;

      // Gets the additional options index
      let index = state.additionalOptionsIndex;

      // Gets the additional options function list.
      // The exclamation mark at the end is to assert
      // to typescript that the function list is defined
      // as this step can only be entered if there are
      // functions in the additional options function list.
      const funcList = state.additionalOptionsFuncList!;

      // Gets the message from the user
      let message = ctx.message.text;

      // Gets the message text from the message
      message = removeBotUsernameAndCommand(message);

      console.log(message);

      // Calls the function at the current index
      // and get whether the function is successful or not
      const success = await funcList[index](ctx, message, state);

      // If the function is successful,
      // increment the additionalOptionxIndex by 1
      if (success) index = ++state.additionalOptionsIndex;

      // If the additional options index is
      // past the length of the function list - 1
      // (length is 1 more than the last index)
      if (index > funcList.length - 1) {

        // Sets the index back to 0
        state.additionalOptionsIndex = 0;

        // Calls the previous step
        return await callStep(ctx, next, true);
      }
    }
  ),
);
