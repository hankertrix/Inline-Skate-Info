// The utility functions for the poll command

import type { Scenes } from "telegraf";
import type { User, InlineKeyboardButton } from "telegraf/types";
import type { CbQuery, ObjectValues } from "../types";
import * as utils from "../utils";
import { removeBotUsername } from "../bot-utils"
import { SPACING } from "../../src/lib/constants";


// The enum representing the various poll types
export const POLL_TYPES = {
  DEFAULT: utils.generateZeroWidthCode("default"),
  RENTAL: utils.generateZeroWidthCode("rental"),
} as const;

// The type of poll
export type PollType = ObjectValues<typeof POLL_TYPES>;

// The enum representing the numbering styles for the poll
export const NUMBERING_STYLES = {
  NONE: "",
  DASH: "-",
  ARROWHEAD: ">",
  EQUAL: "=",
  PLUS: "+",
  TILDE: "~",
  SMALL_DOT: "Â·",
  BIG_DOT: "â€¢",
  ROUND_BRACKET: "1)",
  NUMBERED_DOT: "1.",
  ROUND_BRACKETS: "(1)",
  SQUARE_BRACKETS: "[1]",
  CURLY_BRACKETS: "{1}",
  ANGLE_BRACKETS: "<1>",
} as const;

// The regex to get the numbering style
// and the name from the poll option segment
const numberingStyleAndNameRegex =
  /^\s*?([->=+~â€¢Â·([{<]?\d*[).\]}>]?)\s*(.*?)\s*()$/gm;

// The regex to create the numbering from the numbering style
const createNumberingRegex = /\d+/;

// The type for the numbering styles
export type NumberingStyle = ObjectValues<typeof NUMBERING_STYLES>;

// The default poll options
export const DEFAULT_POLL_OPTIONS = ["Coming"];

// The type of the format option variable
export type FormatOption = {
  formatStr: string,
  default: string,
  zero?: string | null,
  one?: string | null
}

// The type of the format options variable
export type FormatOptions = {
  pollOptionHeader: FormatOption,
  messageFooter: FormatOption
}

// The default format options
export const DEFAULT_FORMAT_OPTIONS: FormatOptions = {

  // The {people} in the formatStr property will be substituted
  // with the string generated by substituting the zero, one, and
  // moreThanOne properties.

  // The {number} in the zero, one and moreThanOne properties
  // will be substituted with the actual number of people who
  // responded to the poll option.

  // The options for the individual options of the poll
  pollOptionHeader: {

    // The format string for the header of a single poll option
    // The {pollOption} in the formatStr will be substituted with
    // the poll option.
    formatStr: "{pollOption} {people}",

    // The string to display when there is more than one person.
    // This is also the string that will be used if no string is given
    // for zero and one.
    default: "({number}ðŸ‘¥)",

    // The string to display when there is no one
    zero: "",

    // The string to display when there is one person
    one: null
  },

  // The options for the message footer
  messageFooter: {

    // The format string for the header of the poll message.
    formatStr: "ðŸ‘¥ {people} responded",

    // The string to display when there is more than one person.
    // This is also the string that will be used if no string is given
    // for zero and one.
    default: "{number} people",

    // The string to display when there is no one
    zero: "Nobody",

    // The string to display when there is one person
    one: "1 person"
  }
}

// The regex for the poll message command
export const pollMessageRegex = /^\/?\bpoll_?(?:msg|message)?\b/i;

// Function to generate the inline keyboard markup
export function generateInlineKeyboard(
  pollOptions: string[] = DEFAULT_POLL_OPTIONS
) {

  // The list of inline keyboard buttons
  const inlineKeyboard = [];

  // Iterates over the poll options and add their buttons to the list
  for (const pollOption of pollOptions) {

    // Adds the poll option button to the list
    inlineKeyboard.push([{
      text: pollOption,
      callback_data: pollOption
    }]);
  }

  // Returns the inline keyboard object
  return inlineKeyboard;
}


// Function to generate the callback function for the poll message command
export function generatePollMessage(
  message: string,
  pollOptions: string[],
  pollType: PollType = POLL_TYPES.DEFAULT,
  formatOption: FormatOption = DEFAULT_FORMAT_OPTIONS.messageFooter
) {

  // Remove the command from the message
  message = message.replace(pollMessageRegex, "").trim();

  // Remove the bot's username from the message
  message = removeBotUsername(message);

  // Generate the portion of the message that is a poll
  const pollPortion = `${pollOptions.map(
    option => `${utils.bold(option)}`
  ).join(SPACING)}${SPACING}${createNumberOfPeoplePortion(
    0, formatOption
  )}`;

  // Gets the inline keyboard
  const inlineKeyboard = generateInlineKeyboard(pollOptions);

  // The callback function
  async function callback(ctx: Scenes.WizardContext, input: string) {

    // Bold the first line of the input
    input = utils.boldFirstLine(input);

    // Sends a poll with the user's input
    return await ctx.reply(
      `${input}${pollType}\n\n${pollPortion}`,
      {
        parse_mode: "HTML",
        reply_markup: {
          inline_keyboard: inlineKeyboard
        }
      });
  }

  // Returns the message and the callback function
  return { message: message, callback: callback };
}




// All functions relating to the callback query from the poll

// Function to get the poll option segment
export function getPollOptionSegment(message: string, pollOption: string) {

  // Gets the index of the poll option in the message
  // and set it to zero if the index is not found
  const pollOptionIndex = message.indexOf(
    pollOption
  ) === -1 ? 0 : message.indexOf(pollOption);

  // Find the index of the new line after the poll option
  let newLineAfterPollOptionIndex = message.indexOf("\n", pollOptionIndex);

  // Sets the index of the new line after the poll option to 0
  // if it's not found
  newLineAfterPollOptionIndex =
    newLineAfterPollOptionIndex === -1 ? 0 : newLineAfterPollOptionIndex;

  // Searches for the next double new line in the message slice
  // after the poll option
  let doubleNewLineIndex = message.indexOf(
    "\n\n", newLineAfterPollOptionIndex + 1
  );

  // Set the index for the next double new line to the end of the message
  // if it's not found
  doubleNewLineIndex =
    doubleNewLineIndex === -1 ? message.length : doubleNewLineIndex;

  // Gets the part of the message with the list of names
  const pollOptionSegment = message.slice(
    newLineAfterPollOptionIndex, doubleNewLineIndex
  ).trim();

  // Returns the poll option segment
  return pollOptionSegment;
}


// Function to create the numbering from the numbering style
function createNumbering(numberingStyle: string, index: number) {
  return numberingStyle.replace(createNumberingRegex, `${index + 1}`);
}


// Function to create the number of people portion of the poll message.
function createNumberOfPeoplePortion(
  numberOfPeople: number,
  formatOption: FormatOption,
  additionalSubstitutions: { [key: string]: string } = {}
) {

  // Initialise the number format string
  let numberFormatString: string | null | undefined = null;

  // Switch statement to get the correct format string
  switch (numberOfPeople) {

    // The default case, where the number of people
    // is not 0 or 1
    default:
      numberFormatString = formatOption.default;
    break;

    case 0:
      numberFormatString = formatOption.zero;
    break;

    case 1:
      numberFormatString = formatOption.one;
    break;
  }

  // If the number format string is null,
  // set the number format string to the default one
  if (numberFormatString == null) {
    numberFormatString = formatOption.default;
  }

  // Gets the string for the number of people who responded
  const numberOfPeopleString = utils.strFormat(
    numberFormatString,
    { number: numberOfPeople }
  );

  // Returns the header for the poll option
  return utils.bold(
    utils.strFormat(
      formatOption.formatStr,
      { people: numberOfPeopleString, ...additionalSubstitutions }
    )
  )
}


// Function to create the poll portion for a given poll option
export function createPollPortion(
  message: string,
  pollOption: string,
  selected: boolean,
  givenName: string | null,
  formatOption: FormatOption = DEFAULT_FORMAT_OPTIONS.pollOptionHeader,
  tagString: string | null = null,
  preserveNumbering: boolean = false
) {

  // Gets the poll option segment of the message
  const pollOptionSegment = getPollOptionSegment(message, pollOption);

  // Initialise the regular expression to the
  // globally defined numbering style and name regex
  let regex = numberingStyleAndNameRegex;

  // If the tag string is given
  if (tagString) {

    // Escape all the characters in the tag string
    tagString = Array.from(tagString).map(char => `\\${char}`).join("");

    // Recreate the regular expression to add the tag string
    regex = new RegExp(
      `${numberingStyleAndNameRegex.source.replace(
        /\(\)\$$/, `((?:${tagString})?)$`
      )}`,
      numberingStyleAndNameRegex.flags
    )
  }

  // Get the numbering style and the names
  // from the poll option segment
  const matches = Array.from(
    pollOptionSegment.matchAll(regex)
  );

  // Initialise the numbering styles variable
  let numberingStyle: string = NUMBERING_STYLES.NONE;

  // Initialise the encountered variable
  // to indicate whether the given name has been
  // encountered or not
  let encountered = false;

  // Initialised the removed variable
  // (the variable to indicate whether the name has been added
  // or removed to the poll option)
  let removed: boolean | null = null;

  // Initialise the tagged variable
  // This variable indicates whether
  // the name has been tagged or not.
  // If the value is null,
  // that means the person's name
  // hasn't been added to the list.
  let tagged: boolean | null = null;

  // Initialise the list of string to get the poll portion
  const pollPortionList: string[] = [];

  // Initialise the list of names
  const names: string[] = [];

  // Iterates over the matches
  for (const [index, [ , numStyle, name, tag]] of matches.entries()) {

    // Gets the trimmed name
    const trimmedName = name.trim();

    // If it's the first item
    if (index === 0) {

      // Set the numbering style
      numberingStyle = numStyle
    }

    // If the name is empty, continue the loop
    if (!trimmedName) continue;

    // Create the numbering
    const numbering = createNumbering(numberingStyle, index);

    // Otherwise, if the name is selected and the name is the given name
    if (trimmedName === givenName && selected) {

      // Set the encountered variable to true
      encountered = true;

      // If the tag string is given
      if (tagString) {

        // Sets the tagged variable
        tagged = tag ? true : false;

        // Add or remove the tag depending on whether the tag is already there
        // and add the string to the poll portion list
        pollPortionList.push(
          `${numbering} ${trimmedName} ${tag ? "" : tagString}`.trim()
        );
      }

      // Otherwise, if no tag string is given
      else {

        // Set the removed variable to true
        removed = true;

        // Continue the loop to remove the name from the list
        continue;
      }
    }

    // Otherwise, if the name is not the given name
    else {

      // Adds the numbering style, name, and the tag
      // to the poll portion list
      pollPortionList.push(`${numbering} ${trimmedName} ${tag}`);
    }

    // Add the name to the list of names
    names.push(trimmedName);
  }

  // If the given name exists and is selected,
  // and has not been encountered.
  // This means the name wasn't in the list
  // and should be added to the list.
  // Tagging should not be done as the person should
  // already be in the list to be tagged.
  if (selected && givenName && !encountered) {

    // Set the removed variable to false,
    // which means the person has been added to the list
    removed = false;

    // Adds the given name to the list
    // This is done first as the createNumbering function
    // increases the given index by 1
    pollPortionList.push(
      `${createNumbering(numberingStyle, names.length)} ${givenName}`
    );

    // Adds the name to the list of names
    names.push(givenName);
  }

  // If the numbering should be preserved
  if (preserveNumbering) {

    // Iterates from the number of people to the total number of matches
    for (let index = names.length; index < matches.length; ++index) {

      // Adds the numbering to the list
      pollPortionList.push(`${createNumbering(numberingStyle, index)}`);
    }
  }

  // Gets the poll portion header
  const pollPortionHeader = createNumberOfPeoplePortion(
    names.length, formatOption, { pollOption: pollOption }
  );

  // Create the poll portion for the given poll option
  const pollPortion = `${pollPortionHeader}\n${
    pollPortionList.join("\n").trim()
  }`;

  // Returns the poll portion
  // and the number of people responded to this poll portion
  return {
    pollPortion: pollPortion,
    names: names,
    nameRemoved: removed,
    nameTagged: tagged
  };
}


// Function to reform the poll message
export function reformPollMessage(
  message: string,
  pollMessage: string,
  selectedPollOption: string,
  pollOptions: string[],
  name: string,
  formatOptions: FormatOptions = DEFAULT_FORMAT_OPTIONS,
  tagString: string | null = null,
  preserveNumbering: boolean = false
) {

  // The list that contains the final message
  const reformedPollMessageList: string[] = [];

  // The list containing the people who responded to the poll
  let peopleResponded: string[] = [];

  // Initialise the variable to indicate whether the person has been added
  // or removed from the poll
  let removed: boolean | null = null;

  // Adds the poll message and the selected poll portion
  // to the reformed poll message list
  reformedPollMessageList.push(pollMessage);

  // Iterates the list of poll options
  for (const pollOption of pollOptions) {

    // The boolean variable that indicates if the poll option is selected
    const isSelected = pollOption === selectedPollOption;

    // Calls the function to generate the poll portion
    // and get the number of people who responded to that poll option
    const { pollPortion, names, nameRemoved } = createPollPortion(
      message,
      pollOption,
      isSelected,
      isSelected ? name : null,
      formatOptions.pollOptionHeader,
      tagString,
      preserveNumbering
    );

    // Adds the poll portion to the reformed poll message list
    reformedPollMessageList.push(pollPortion);

    // Adds the people who responded to the poll option
    // to the list of people who responded
    peopleResponded = peopleResponded.concat(names);

    // If the nameRemoved variable isn't null,
    // then set the removed variable to its value
    if (nameRemoved !== null) removed = nameRemoved;
  }

  // Gets the number of unique people who responded
  const numResponded = new Set(peopleResponded).size;

  // The portion of the message that says how many people responded
  const respondedPortion = createNumberOfPeoplePortion(
    numResponded, formatOptions.messageFooter
  );

  // Adds the responded portion to the reformed message list
  reformedPollMessageList.push(respondedPortion);

  // Reform the poll message
  const reformedPollMessage = reformedPollMessageList.join("\n\n");

  // Returns the reformed poll message
  return { reformedPollMessage: reformedPollMessage, removed: removed };
}


// Function to get the name of the user
export function getName(user: User) {
  return `${user.first_name} ${user.last_name ?? ""}`.trim();
}


// Function to get the list of poll options
export function getPollOptions(inline_keyboard: InlineKeyboardButton[][]) {

  // The list of poll options
  const pollOptions = [];

  // Iterates the list of inline keyboard buttons
  for (const inlineKeyboardButton of inline_keyboard) {

    // Gets the text for the inline keyboard button
    const text = inlineKeyboardButton[0].text;

    // Adds the text to the list of poll options
    pollOptions.push(text);
  }

  // Returns the list of poll options
  return pollOptions;
}


// Function to get the poll message
export function getPollMessage(message: string, pollOptions: string[]) {

  // Gets the index of the first poll option in the message
  const firstPollOptionIndex = message.indexOf(pollOptions[0]);

  // Returns the poll message with the first line bolded
  return utils.boldFirstLine(message.slice(0, firstPollOptionIndex).trim());
}


// Function to handle a callback query
export async function callback_handler(
  ctx: Scenes.WizardContext,
  pollType: PollType = POLL_TYPES.DEFAULT
) {

  // Gets the callback query object
  const callbackQuery = ctx.callbackQuery as CbQuery;

  // Cast the callback query message type
  const message = callbackQuery.message;

  // Gets the message text
  const messageText = message.text;

  // If the poll type isn't found in the message,
  // immediately exit the function so that
  // another handler can take care of the message
  if (!messageText.includes(pollType)) return;

  // Gets the poll option and the poll message
  const pollOption = callbackQuery.data;

  // If the poll option doesn't exist, then tells the user
  if (messageText.indexOf(pollOption) === -1) return await ctx.answerCbQuery(
    `The option "${
      pollOption
    }" doesn't exist on the poll you are responding to.`
  );

  // Gets the list of poll options
  const pollOptions = getPollOptions(message.reply_markup.inline_keyboard);

  // Gets the poll message
  const pollMessage = getPollMessage(messageText, pollOptions);

  // Gets the name of the person responding
  const name = getName(callbackQuery.from);

  // Gets the reformed poll message
  // and the variable to indicated whether the person has been added
  // or removed from the poll option
  const { reformedPollMessage, removed } = reformPollMessage(
    messageText,
    pollMessage,
    pollOption,
    pollOptions,
    name,
    DEFAULT_FORMAT_OPTIONS
  );

  // Answers the callback query
  await ctx.answerCbQuery(
    `Your name has been ${removed ? "removed from" : "added to"
    } '${pollOption}'!`
  );

  // Edit the message with the reformed poll message
  return await ctx.editMessageText(reformedPollMessage, {
    parse_mode: "HTML",
    reply_markup: {
      inline_keyboard: message.reply_markup.inline_keyboard
    }
  });
}
